{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kurs\u00fcbersicht","text":""},{"location":"#kursinhalte","title":"Kursinhalte:","text":"Thema Beschreibung FastAPI Einf\u00fchrung in FastAPI: Erstellung von APIs und Routen. Pydantic Datenvalidierung und Modellierung mit Pydantic. SQLModel Integration von SQLModel f\u00fcr den Umgang mit Datenbanken in FastAPI. Visualisierungen und Plots \u00dcbersicht zu Grafiken und die Erstellung in Python."},{"location":"#projekte","title":"Projekte:","text":"<p>Hier ist Platz f\u00fcr gemeinsame Projekte, welche in diesem Kurs bearbeitet werden:</p>"},{"location":"data_analysis/data_visualization/","title":"Visualisierungen in der Deskriptiven Statistik","text":"<p>Visualisierungen sind ein grundlegendes Werkzeug, um Daten verst\u00e4ndlich darzustellen und erste Einsichten zu gewinnen. Im Folgenden werden verschiedene Graphen vorgestellt, die sich f\u00fcr unterschiedliche Anwendungsf\u00e4lle eignen.</p>"},{"location":"data_analysis/data_visualization/#1-histogramm","title":"1. Histogramm","text":"<ul> <li>Was zeichnet es aus: Ein Histogramm zeigt die Verteilung einer numerischen Variable, indem es die Daten in aufeinanderfolgende Intervalle unterteilt und die H\u00e4ufigkeit dieser Intervalle als Balken darstellt. Die H\u00f6he eines Balkens repr\u00e4sentiert die Anzahl der Datenpunkte in diesem Intervall.</li> <li>Wann kann ich es besonders gut anwenden: Histogramme sind ideal, um die Verteilung von Daten, insbesondere deren Form (z. B. Normalverteilung, Schiefe) und Streuung, zu visualisieren.</li> <li>Was w\u00e4re eine Alternative: Alternativen zum Histogramm sind Dichteplots oder Boxplots, die ebenfalls Verteilungen darstellen, jedoch mit anderer Betonung.</li> <li>Wie erstelle ich es:<ul> <li>Plotly: Histogram</li> <li>Seaborn: histplot</li> <li>Matplotlib: hist</li> </ul> </li> </ul>"},{"location":"data_analysis/data_visualization/#2-boxplot","title":"2. Boxplot","text":"<ul> <li>Was zeichnet es aus: Ein Boxplot veranschaulicht die Verteilung der Daten durch ein Diagramm, das den Median, die oberen und unteren Quartile sowie potenzielle Ausrei\u00dfer anzeigt. Die \u201eBox\u201c repr\u00e4sentiert den Interquartilsabstand, und \u201eWhiskers\u201c zeigen die Variabilit\u00e4t au\u00dferhalb der Quartile.</li> <li>Wann kann ich es besonders gut anwenden: Boxplots sind besonders n\u00fctzlich, um die Verteilung und die Symmetrie von Daten sowie m\u00f6gliche Ausrei\u00dfer darzustellen. Ideal f\u00fcr den Vergleich von Kategorien oder Gruppen.</li> <li>Was w\u00e4re eine Alternative: Alternativen sind Violinplots, die die Dichte der Verteilung detaillierter darstellen.</li> <li>Wie erstelle ich es:<ul> <li>Plotly: Boxplot</li> <li>Seaborn: boxplot</li> <li>Matplotlib: boxplot</li> </ul> </li> </ul>"},{"location":"data_analysis/data_visualization/#3-streudiagramm-scatter-plot","title":"3. Streudiagramm (Scatter Plot)","text":"<ul> <li>Was zeichnet es aus: Streudiagramme visualisieren die Beziehung zwischen zwei numerischen Variablen. Jeder Punkt auf dem Diagramm repr\u00e4sentiert einen Datenpunkt und die Achsen die Werte der jeweiligen Variablen.</li> <li>Wann kann ich es besonders gut anwenden: Ideal, um Korrelationen oder Muster zwischen zwei Variablen zu erkennen (z. B. ob ein linearer Zusammenhang besteht).</li> <li>Was w\u00e4re eine Alternative: Alternativen sind Liniendiagramme (wenn eine Reihenfolge wichtig ist) oder Heatmaps f\u00fcr dichtere Datens\u00e4tze.</li> <li>Wie erstelle ich es:<ul> <li>Plotly: Scatter Plot</li> <li>Seaborn: scatterplot</li> <li>Matplotlib: scatter</li> </ul> </li> </ul>"},{"location":"data_analysis/data_visualization/#4-liniendiagramm","title":"4. Liniendiagramm","text":"<ul> <li>Was zeichnet es aus: Ein Liniendiagramm verbindet Datenpunkte mittels Linien und veranschaulicht so den Verlauf einer oder mehrerer Reihen \u00fcber eine geordnete Achse (h\u00e4ufig Zeit).</li> <li>Wann kann ich es besonders gut anwenden: Liniendiagramme eignen sich gut f\u00fcr Zeitreihenanalysen und um Trends oder Zyklen in Daten darzustellen.</li> <li>Was w\u00e4re eine Alternative: Eine Alternative w\u00e4re ein Fl\u00e4chendiagramm (Area Chart), das die gleiche Information zeigt, jedoch mit gef\u00fcllten Bereichen.</li> <li>Wie erstelle ich es:<ul> <li>Plotly: Line Chart</li> <li>Seaborn: lineplot</li> <li>Matplotlib: plot</li> </ul> </li> </ul>"},{"location":"data_analysis/data_visualization/#5-violinplot","title":"5. Violinplot","text":"<ul> <li>Was zeichnet es aus: Der Violinplot kombiniert Elemente von Boxplots und Dichteplots und zeigt die Verteilung der Daten sowie deren Dichte entlang einer Achse.</li> <li>Wann kann ich es besonders gut anwenden: Violinplots sind n\u00fctzlich, wenn man die Verteilung und die Dichte einer Variablen gleichzeitig darstellen und dabei symmetrische oder bimodale Muster aufzeigen m\u00f6chte.</li> <li>Was w\u00e4re eine Alternative: Alternativen sind der Boxplot (f\u00fcr eine weniger detaillierte Darstellung der Dichte) oder der Dichteplot.</li> <li>Wie erstelle ich es:<ul> <li>Plotly: Violin Plot</li> <li>Seaborn: violinplot</li> <li>Matplotlib: violinplot</li> </ul> </li> </ul>"},{"location":"data_analysis/data_visualization/#6-heatmap","title":"6. Heatmap","text":"<ul> <li>Was zeichnet es aus: Heatmaps verwenden Farbschattierungen, um die Intensit\u00e4t von Werten in einer Matrix zu visualisieren. H\u00e4ufig werden sie verwendet, um Korrelationen zwischen Variablen darzustellen.</li> <li>Wann kann ich es besonders gut anwenden: Heatmaps sind besonders n\u00fctzlich, um Korrelationen zwischen vielen Variablen darzustellen, etwa bei der Analyse von Korrelationen in gro\u00dfen Datens\u00e4tzen.</li> <li>Was w\u00e4re eine Alternative: Eine Alternative zur Heatmap ist das Paarplot, das Korrelationen in Scatterplot-Matrizen zeigt.</li> <li>Wie erstelle ich es:<ul> <li>Plotly: Heatmap</li> <li>Seaborn: heatmap</li> <li>Matplotlib: imshow</li> </ul> </li> </ul>"},{"location":"data_analysis/data_visualization/#7-paarplot-pair-plot","title":"7. Paarplot (Pair Plot)","text":"<ul> <li>Was zeichnet es aus: Ein Paarplot visualisiert alle Kombinationen der Variablenpaare in einem Datensatz als Streudiagramme und eignet sich hervorragend zur Erkennung von Korrelationen und Zusammenh\u00e4ngen in multidimensionalen Datens\u00e4tzen.</li> <li>Wann kann ich es besonders gut anwenden: Wenn es darum geht, Korrelationen und Beziehungen zwischen mehreren Variablen gleichzeitig zu analysieren, ist der Paarplot das Mittel der Wahl.</li> <li>Was w\u00e4re eine Alternative: Alternativen sind Scatterplot-Matrizen oder einzelne Heatmaps.</li> <li>Wie erstelle ich es:<ul> <li>Seaborn: pairplot</li> <li>Plotly: scatter_matrix</li> </ul> </li> </ul>"},{"location":"data_analysis/data_visualization/#8-balkendiagramm-bar-chart","title":"8. Balkendiagramm (Bar Chart)","text":"<ul> <li>Was zeichnet es aus: Ein Balkendiagramm stellt kategorische Daten durch rechteckige Balken dar, deren L\u00e4nge proportional zur H\u00e4ufigkeit oder zum Wert einer Kategorie ist.</li> <li>Wann kann ich es besonders gut anwenden: Balkendiagramme sind ideal, um die Gr\u00f6\u00dfenverh\u00e4ltnisse verschiedener Kategorien direkt miteinander zu vergleichen.</li> <li>Was w\u00e4re eine Alternative: Eine Alternative zum Balkendiagramm ist das S\u00e4ulendiagramm, das \u00e4hnliche Daten vertikal darstellt.</li> <li>Wie erstelle ich es:<ul> <li>Plotly: Bar Chart</li> <li>Seaborn: barplot</li> <li>Matplotlib: bar</li> </ul> </li> </ul>"},{"location":"data_analysis/data_visualization/#9-kreisdiagramm-pie-chart","title":"9, Kreisdiagramm (Pie Chart)","text":"<ul> <li>Was zeichnet es aus: Ein Kreisdiagramm teilt einen Kreis in Segmente, die jeweils eine Kategorie repr\u00e4sentieren, und zeigt deren Anteile am Gesamtwert.</li> <li>Wann kann ich es besonders gut anwenden: Kreisdiagramme sind gut geeignet, um den Anteil einer Kategorie im Verh\u00e4ltnis zum Ganzen darzustellen, allerdings nicht bei mehr als f\u00fcnf Kategorien.</li> <li>Was w\u00e4re eine Alternative: Alternativen sind Donut Charts oder gestapelte Balkendiagramme, die Verh\u00e4ltnisse auch darstellen k\u00f6nnen.</li> <li>Wie erstelle ich es:<ul> <li>Plotly: Pie Chart</li> <li>Matplotlib: pie</li> </ul> </li> </ul>"},{"location":"data_analysis/data_visualization/#10-flachendiagramm-area-chart","title":"10. Fl\u00e4chendiagramm (Area Chart)","text":"<ul> <li>Was zeichnet es aus: Ein Fl\u00e4chendiagramm ist eine Variation des Liniendiagramms, bei dem der Bereich unter der Linie ausgef\u00fcllt ist, um den Wert \u00fcber eine geordnete Dimension (h\u00e4ufig Zeit) zu verdeutlichen.</li> <li>Wann kann ich es besonders gut anwenden: Fl\u00e4chendiagramme eignen sich besonders, um kumulative Daten oder Zeitreihendaten zu visualisieren, bei denen der Bereich unter der Linie eine Bedeutung hat.</li> <li>Was w\u00e4re eine Alternative: Liniendiagramme (ohne ausgef\u00fcllte Fl\u00e4che) oder Stapeldiagramme, wenn mehrere Kategorien dargestellt werden sollen.</li> <li>Wie erstelle ich es:<ul> <li>Plotly: Area Chart</li> <li>Matplotlib: fill_between</li> </ul> </li> </ul>"},{"location":"data_analysis/data_visualization/#11-blasendiagramm-bubble-chart","title":"11. Blasendiagramm (Bubble Chart)","text":"<ul> <li>Was zeichnet es aus: Ein Blasendiagramm ist ein erweitertes Streudiagramm, bei dem die Gr\u00f6\u00dfe der Punkte eine zus\u00e4tzliche Dimension repr\u00e4sentiert, meist einen numerischen Wert.</li> <li>Wann kann ich es besonders gut anwenden: Blasendiagramme sind n\u00fctzlich, wenn man drei Dimensionen (zwei f\u00fcr die Achsen und eine f\u00fcr die Punktgr\u00f6\u00dfe) auf einmal visualisieren m\u00f6chte.</li> <li>Was w\u00e4re eine Alternative: Alternativen sind einfache Streudiagramme (f\u00fcr zwei Dimensionen) oder Heatmaps f\u00fcr Korrelationen zwischen mehreren Variablen.</li> <li>Wie erstelle ich es:<ul> <li>Plotly: Bubble Chart</li> <li>Matplotlib: scatter (mit Gr\u00f6\u00dfenparameter)</li> </ul> </li> </ul>"},{"location":"data_analysis/data_visualization/#12-gestapeltes-balkendiagramm-stacked-bar-chart","title":"12. Gestapeltes Balkendiagramm (Stacked Bar Chart)","text":"<ul> <li>Was zeichnet es aus: Ein gestapeltes Balkendiagramm zeigt mehrere Kategorien \u00fcbereinander in einem Balken, wodurch die Gesamtmenge sowie die Verteilung der Teilkategorien auf einen Blick erkennbar sind.</li> <li>Wann kann ich es besonders gut anwenden: Diese Darstellung eignet sich f\u00fcr Daten, bei denen man sowohl die Gesamtwerte als auch die Anteile der Unterkategorien gleichzeitig zeigen m\u00f6chte.</li> <li>Was w\u00e4re eine Alternative: Eine Alternative ist das 100%-gestapelte Balkendiagramm, bei dem die Balken normalisiert werden, sodass sie immer bis 100% reichen.</li> <li>Wie erstelle ich es:<ul> <li>Plotly: Stacked Bar Chart</li> <li>Matplotlib: bar (mit stacked=True)</li> </ul> </li> </ul>"},{"location":"data_analysis/eda_steps/","title":"Deskriptive Datenanalyse","text":""},{"location":"data_analysis/eda_steps/#einfuhrung-in-die-explorative-datenanalyse-eda","title":"Einf\u00fchrung in die Explorative Datenanalyse (EDA)","text":"<p>In der explorativen Datenanalyse (EDA) werfen wir einen ersten Blick auf unsere Daten, um die wichtigsten Merkmale des Datensatzes zu erfassen und zu visualisieren. Diese Schritte helfen uns, die Daten besser zu verstehen, Hypothesen zu formulieren, und schlie\u00dflich die Voraussetzungen f\u00fcr eine fundierte Analyse oder ein Modell zu schaffen. Im Folgenden f\u00fchren wir dich Schritt f\u00fcr Schritt durch die f\u00fcnf wesentlichen Schritte einer EDA.</p>"},{"location":"data_analysis/eda_steps/#schritt-1-verstehen-der-datenstruktur","title":"Schritt 1: Verstehen der Datenstruktur","text":""},{"location":"data_analysis/eda_steps/#11-datentypen-und-strukturen","title":"1.1 Datentypen und Strukturen","text":"<ul> <li>Daten werden meist in numerische, kategorische und Zeitreihen-Daten unterteilt, und jeder Typ braucht besondere Techniken und Darstellungen.</li> <li>Nutze Datenstrukturen wie DataFrames (Pandas in Python) und Arrays (NumPy), um Daten zu laden und effizient zu verarbeiten.</li> </ul>"},{"location":"data_analysis/eda_steps/#12-kontext-und-quelle-der-daten","title":"1.2 Kontext und Quelle der Daten","text":"<ul> <li>Woher kommen die Daten? Wann wurden sie gesammelt? Notiere den Kontext, um den Zweck der Daten zu verstehen und m\u00f6gliche Verzerrungen zu erkennen.</li> </ul>"},{"location":"data_analysis/eda_steps/#13-metadaten-und-dokumentation","title":"1.3 Metadaten und Dokumentation","text":"<ul> <li>Wenn verf\u00fcgbar, \u00fcberpr\u00fcfe die Metadaten und die Dokumentation zum Datensatz. Das liefert oft wichtige Hinweise zu den Variablen und der Datenqualit\u00e4t.</li> </ul>"},{"location":"data_analysis/eda_steps/#schritt-2-datenbereinigung-und-vorverarbeitung","title":"Schritt 2: Datenbereinigung und Vorverarbeitung","text":""},{"location":"data_analysis/eda_steps/#21-fehlende-werte-behandeln","title":"2.1 Fehlende Werte behandeln","text":"<ul> <li>Optionen: Zeilen oder Spalten entfernen, fehlende Werte mit Durchschnitt oder Median auff\u00fcllen, oder Vorhersagemodelle nutzen, um die Werte zu sch\u00e4tzen.</li> </ul>"},{"location":"data_analysis/eda_steps/#22-duplikate-entfernen","title":"2.2 Duplikate entfernen","text":"<ul> <li>Doppelte Eintr\u00e4ge in deinem Datensatz verf\u00e4lschen Ergebnisse. Entferne sie, um die Integrit\u00e4t deiner Daten zu sichern.</li> </ul>"},{"location":"data_analysis/eda_steps/#23-transformation-der-daten","title":"2.3 Transformation der Daten","text":"<ul> <li>Normalisierung: Skalierung der Daten f\u00fcr eine einheitliche Verteilung.</li> <li>Kodierung: Umwandlung von Kategorien in numerische Werte (z.B. One-Hot-Codierung).</li> <li>Zeitreihen: Konvertiere Datumsangaben f\u00fcr eine korrekte Analyse von Zeitdaten.</li> </ul>"},{"location":"data_analysis/eda_steps/#24-ausreier-identifizieren-und-behandeln","title":"2.4 Ausrei\u00dfer identifizieren und behandeln","text":"<ul> <li>Verwende Diagramme wie Boxplots oder statistische Tests (z.B. Z-Scores), um Ausrei\u00dfer zu finden. Entschlie\u00dfe, ob du diese entfernst oder transformierst.</li> </ul>"},{"location":"data_analysis/eda_steps/#schritt-3-univariate-analyse-einzelne-variablen","title":"Schritt 3: Univariate Analyse (Einzelne Variablen)","text":""},{"location":"data_analysis/eda_steps/#31-deskriptive-statistik","title":"3.1 Deskriptive Statistik","text":"<ul> <li>F\u00fchre grundlegende statistische Berechnungen durch (Mittelwert, Median, Modus), um zentrale Tendenzen und Streuung der Variablen zu verstehen.</li> </ul>"},{"location":"data_analysis/eda_steps/#32-visualisierungen-univariate","title":"3.2 Visualisierungen (Univariate)","text":"<ul> <li>Histogramme: Zum Veranschaulichen der Verteilung.</li> <li>Boxplots: Zeigen Verteilung und Ausrei\u00dfer.</li> <li>Balkendiagramme: F\u00fcr die H\u00e4ufigkeit von Kategorien.</li> </ul>"},{"location":"data_analysis/eda_steps/#schritt-4-bivariate-und-multivariate-analyse-zusammenhange","title":"Schritt 4: Bivariate und multivariate Analyse (Zusammenh\u00e4nge)","text":""},{"location":"data_analysis/eda_steps/#41-bivariate-analyse","title":"4.1 Bivariate Analyse","text":"<ul> <li>Scatterplots: Visualisiert die Beziehung zwischen zwei numerischen Variablen.</li> <li>Korrelationsmatrix: Berechnet Korrelationen zwischen Variablen.</li> </ul>"},{"location":"data_analysis/eda_steps/#42-multivariate-analyse","title":"4.2 Multivariate Analyse","text":"<ul> <li>Paarplots und Heatmaps: Zeigen Beziehungen mehrerer Variablen.</li> <li>PCA (Principal Component Analysis): Reduziert die Komplexit\u00e4t der Daten.</li> <li>Clustering: Zum Gruppieren von Datenpunkten basierend auf \u00c4hnlichkeiten.</li> </ul>"},{"location":"data_analysis/eda_steps/#43-wechselwirkungen-erkennen","title":"4.3 Wechselwirkungen erkennen","text":"<ul> <li>Achte auf Wechselwirkungen zwischen Variablen, die m\u00f6glicherweise auf komplexe Abh\u00e4ngigkeiten oder Multikollinearit\u00e4t hinweisen.</li> </ul>"},{"location":"data_analysis/eda_steps/#schritt-5-einblicke-und-schlussfolgerungen-ziehen","title":"Schritt 5: Einblicke und Schlussfolgerungen ziehen","text":""},{"location":"data_analysis/eda_steps/#51-wichtige-erkenntnisse-zusammenfassen","title":"5.1 Wichtige Erkenntnisse zusammenfassen","text":"<ul> <li>Notiere die wichtigsten Muster und Ausrei\u00dfer. Welche Einblicke bieten deine Analysen?</li> </ul>"},{"location":"data_analysis/eda_steps/#52-visuelles-storytelling","title":"5.2 Visuelles Storytelling","text":"<ul> <li>Nutze ansprechende Diagramme, um deine Ergebnisse zu kommunizieren. Erstelle klare Visualisierungen, die die Daten einfach und verst\u00e4ndlich zusammenfassen.</li> </ul>"},{"location":"data_analysis/eda_steps/#53-entscheidungen-treffen","title":"5.3 Entscheidungen treffen","text":"<ul> <li>Verwende die Erkenntnisse der EDA, um Hypothesen zu formulieren, strategische Entscheidungen zu treffen oder n\u00e4chste Schritte f\u00fcr Modellierungen festzulegen.</li> </ul>"},{"location":"data_analysis/eda_steps/#54-dokumentation","title":"5.4 Dokumentation","text":"<ul> <li>Dokumentiere die EDA-Schritte, Methoden und Ergebnisse vollst\u00e4ndig, damit der Prozess nachvollziehbar und wiederholbar bleibt.</li> </ul>"},{"location":"data_analysis/intro/","title":"Data Analysis","text":"<p>Die Datenanalyse ist ein wesentlicher Bestandteil der Data Science und bildet die Grundlage f\u00fcr datengetriebene Entscheidungen und Erkenntnisse. Sie umfasst verschiedene Analyseans\u00e4tze, die uns helfen, aus Daten Informationen zu gewinnen und diese zielgerichtet zu nutzen. Im Wesentlichen l\u00e4sst sich die Datenanalyse in vier Hauptarten unterteilen, die jeweils unterschiedliche Fragen beantworten und unterschiedliche Methoden anwenden.</p>"},{"location":"data_analysis/intro/#die-vier-arten-der-datenanalyse","title":"Die vier Arten der Datenanalyse","text":""},{"location":"data_analysis/intro/#1-deskriptive-analyse","title":"1. Deskriptive Analyse","text":"<p>Die deskriptive Analyse stellt die Daten so dar, wie sie sind, und beantwortet grundlegende Fragen wie \u201eWas ist passiert?\u201c. Sie wird h\u00e4ufig als erster Schritt verwendet, um Muster, Trends und Verteilungen zu verstehen. Hierbei kommen statistische Kennzahlen wie Mittelwerte, H\u00e4ufigkeiten und Standardabweichungen zum Einsatz, um ein klares Bild der Daten zu gewinnen.</p>"},{"location":"data_analysis/intro/#2-diagnostische-analyse","title":"2. Diagnostische Analyse","text":"<p>Die diagnostische Analyse geht tiefer und versucht zu erkl\u00e4ren, \u201eWarum ist etwas passiert?\u201c. Sie analysiert Zusammenh\u00e4nge und identifiziert Muster, die auf Ursachen f\u00fcr bestimmte Beobachtungen hinweisen. Mit Methoden wie Hypothesentests und Regressionsanalysen lassen sich Korrelationen und Abh\u00e4ngigkeiten aufzeigen, die helfen, den Hintergrund eines Ph\u00e4nomens zu verstehen.</p>"},{"location":"data_analysis/intro/#3-pradiktive-analyse","title":"3. Pr\u00e4diktive Analyse","text":"<p>Die pr\u00e4diktive Analyse richtet den Blick in die Zukunft und versucht zu prognostizieren, \u201eWas wird wahrscheinlich passieren?\u201c. Durch die Analyse historischer Daten und das Erkennen von Mustern lassen sich Modelle entwickeln, die Vorhersagen erm\u00f6glichen. H\u00e4ufige Werkzeuge sind hier maschinelle Lernverfahren wie Regression, Entscheidungsb\u00e4ume und Zeitreihenanalysen, die bei der Ermittlung zuk\u00fcnftiger Trends und Entwicklungen unterst\u00fctzen.</p>"},{"location":"data_analysis/intro/#4-praskriptive-analyse","title":"4. Pr\u00e4skriptive Analyse","text":"<p>Die pr\u00e4skriptive Analyse baut auf den Erkenntnissen der pr\u00e4diktiven Analyse auf und stellt die Frage \u201eWas sollte getan werden?\u201c. Sie nutzt die erlangten Einsichten, um Handlungsempfehlungen zu geben und optimale Entscheidungen zu treffen. Typische Methoden umfassen Optimierungsalgorithmen und Entscheidungsmodelle, die konkrete Vorschl\u00e4ge zur Vorgehensweise bieten.</p> <p>Diese vier Analysearten bilden den Rahmen der Datenanalyse und stehen oft miteinander in Verbindung: Deskriptive und diagnostische Analysen geben Einblick in bestehende Daten, w\u00e4hrend pr\u00e4diktive und pr\u00e4skriptive Analysen darauf abzielen, zuk\u00fcnftige Ergebnisse vorherzusagen und zu beeinflussen. Gemeinsam erm\u00f6glichen sie eine umfassende Datenanalyse und er\u00f6ffnen wertvolle Perspektiven f\u00fcr datenbasierte Entscheidungen. </p> <p>Um die Datenlage verst\u00e4ndlich darzustellen und erste wertvolle Erkenntnisse zu gewinnen, werden in der deskriptiven Statistik grundlegende Methoden und Visualisierungen angewendet. Dieser n\u00e4chste Abschnitt konzentriert sich darauf, wie Datenmuster erkennbar gemacht und wichtige Verteilungen sowie Beziehungen visualisiert werden k\u00f6nnen.</p> <p>Im Fokus stehen dabei die verschiedenen Arten von Diagrammen und Graphen, die in der deskriptiven Statistik g\u00e4ngige Praxis sind, wie etwa Histogramme, Boxplots und Streudiagramme. Zus\u00e4tzlich betrachten wir einige der wichtigsten Bibliotheken in Python \u2013 darunter Matplotlib, Seaborn und Plotly.</p>"},{"location":"data_analysis/understand_datasets/","title":"Datens\u00e4tze verstehen","text":""},{"location":"data_analysis/understand_datasets/#einstieg-in-einen-neuen-datensatz-tipps-zur-orientierung","title":"Einstieg in einen neuen Datensatz: Tipps zur Orientierung","text":"<p>Bevor wir mit einer tiefgehenden Analyse beginnen, ist es hilfreich, uns zuerst einen \u00dcberblick \u00fcber den Datensatz zu verschaffen. Ein strukturierter Ansatz sorgt daf\u00fcr, dass wir die Eigenschaften, St\u00e4rken und eventuelle Herausforderungen der Daten fr\u00fchzeitig erkennen. Hier sind einige wichtige Schritte und Ans\u00e4tze, die dir dabei helfen, dich in einem neuen Datensatz zurechtzufinden:</p>"},{"location":"data_analysis/understand_datasets/#1-datenquellen-und-kontext-prufen","title":"1. Datenquellen und Kontext pr\u00fcfen","text":"<ul> <li>Datenquelle und Kontext verstehen: Woher kommen die Daten? Stammt der Datensatz aus einer verl\u00e4sslichen Quelle? Was ist das Ziel oder der Anwendungsfall der Daten? </li> <li>Datenfelder und Bedeutung: Kl\u00e4re die Bedeutung der einzelnen Felder. Die Dokumentation oder begleitende Metadaten enthalten oft wertvolle Informationen zu den Variablen.</li> </ul>"},{"location":"data_analysis/understand_datasets/#2-uberblick-uber-die-struktur-des-datensatzes-gewinnen","title":"2. \u00dcberblick \u00fcber die Struktur des Datensatzes gewinnen","text":"<ul> <li>Spalten und Datentypen inspizieren: Nutze Python-Methoden wie <code>df.info()</code> oder <code>df.dtypes</code>, um schnell festzustellen, welche Datentypen (numerisch, kategorisch, zeitbasiert) vorhanden sind.</li> <li>Erste Einblicke in die Werte: Verwende <code>df.head()</code> und <code>df.tail()</code>, um dir die ersten und letzten Zeilen anzuschauen und ein Gef\u00fchl f\u00fcr die Dateninhalte zu bekommen. So erkennst du auch direkt m\u00f6gliche Anomalien.</li> </ul>"},{"location":"data_analysis/understand_datasets/#3-zentrale-kennzahlen-berechnen","title":"3. Zentrale Kennzahlen berechnen","text":"<ul> <li>Deskriptive Statistik: Nutze Methoden wie <code>df.describe()</code>, um erste statistische Einblicke zu gewinnen. Kennzahlen wie Mittelwert, Minimum, Maximum und Standardabweichung zeigen wichtige Eigenschaften der numerischen Variablen.</li> <li>Verteilung der Daten pr\u00fcfen: Einfache Histogramme oder Boxplots helfen, die Verteilung der Daten besser zu verstehen und Ausrei\u00dfer oder Verzerrungen zu identifizieren.</li> </ul>"},{"location":"data_analysis/understand_datasets/#4-datenqualitat-beurteilen","title":"4. Datenqualit\u00e4t beurteilen","text":"<ul> <li>Fehlende Werte analysieren: Pr\u00fcfe, ob und wo Werte fehlen. Methoden wie <code>df.isnull().sum()</code> zeigen, wie h\u00e4ufig fehlende Werte in jeder Spalte auftreten.</li> <li>Duplikate finden und bewerten: Mit <code>df.duplicated().sum()</code> erkennst du doppelte Eintr\u00e4ge, die du ggf. bereinigen solltest.</li> </ul>"},{"location":"data_analysis/understand_datasets/#5-erste-zusammenhange-und-muster-erkennen","title":"5. Erste Zusammenh\u00e4nge und Muster erkennen","text":"<ul> <li>Korrelationen untersuchen: Ein schneller Blick auf die Korrelationen numerischer Variablen (z.B. mit <code>df.corr()</code>) kann n\u00fctzliche Hinweise auf Beziehungen zwischen Variablen geben.</li> <li>Kategoriale und numerische Variablen analysieren: Einfache Kreuztabellen (<code>pd.crosstab()</code>) oder Gruppenstatistiken (<code>df.groupby()</code>) helfen, Verteilungen und Zusammenh\u00e4nge zu verstehen.</li> </ul>"},{"location":"data_analysis/understand_datasets/#6-erste-visualisierungen-nutzen","title":"6. Erste Visualisierungen nutzen","text":"<ul> <li>Visualisierung der wichtigsten Felder: Nutze Diagramme wie Balkendiagramme, Histogramme oder Boxplots, um zentrale Eigenschaften der Variablen visuell darzustellen. Dies hilft, Muster zu erkennen und eine Grundlage f\u00fcr detailliertere Analysen zu schaffen.</li> </ul>"},{"location":"fastapi/data_models/","title":"Datenmodelle mit Pydantic in FastAPI","text":"<p>Datenmodelle sind ein wesentlicher Bestandteil von APIs, da sie definieren, welche Art von Daten zwischen dem Server und den Clients ausgetauscht werden kann. In FastAPI \u00fcbernimmt die Bibliothek Pydantic diese Aufgabe, indem sie Python-Datenstrukturen in valide JSON-Objekte verwandelt. Pydantic bietet starke Validierungs- und Typisierungsfunktionen und erm\u00f6glicht es uns, Daten mit minimalem Aufwand zu strukturieren und zu validieren.</p>"},{"location":"fastapi/data_models/#warum-pydantic","title":"Warum Pydantic?","text":"<p>Pydantic ist eine zentrale Bibliothek in FastAPI, da sie eine einfache M\u00f6glichkeit bietet, Daten zu validieren und zu serialisieren. Mit Pydantic k\u00f6nnen wir sicherstellen, dass die Daten, die von einem Client gesendet werden oder an diesen zur\u00fcckgegeben werden, den gew\u00fcnschten Typen entsprechen. Dies verringert potenzielle Fehler und macht den Code robuster und lesbarer.</p>"},{"location":"fastapi/data_models/#typisierung-und-validierung","title":"Typisierung und Validierung","text":"<p>Pydantic nutzt Python\u2019s Typannotation, um die Struktur der Daten zu definieren und die Validierung basierend auf den angegebenen Datentypen durchzuf\u00fchren. Wenn du also ein Modell mit Feldern wie <code>str</code>, <code>int</code> oder <code>EmailStr</code> erstellst, stellt Pydantic sicher, dass die Daten den entsprechenden Typen entsprechen.</p> <p>Ein Beispiel f\u00fcr eine einfache Typisierung:</p> <pre><code>from pydantic import BaseModel, EmailStr\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n    age: int\n</code></pre> <p>Hier sorgt Pydantic daf\u00fcr, dass die <code>email</code>-Adresse als g\u00fcltige E-Mail-Adresse formatiert ist, w\u00e4hrend der Name ein String und das Alter eine Ganzzahl ist.</p>"},{"location":"fastapi/data_models/#unterstutzte-datentypen","title":"Unterst\u00fctzte Datentypen","text":"<p>Pydantic unterst\u00fctzt eine breite Palette von Datentypen, um unterschiedliche Anwendungsf\u00e4lle abzudecken. Zu den wichtigsten geh\u00f6ren:</p> <ul> <li>Primitive Typen: <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code></li> <li>Spezielle Typen: <code>EmailStr</code>, <code>UUID</code>, <code>IPv4</code>, <code>IPv6</code></li> <li>Optionale Felder: <code>Optional[T]</code>, um Felder als optional zu kennzeichnen</li> <li>Listen und Tupel: <code>List[T]</code>, <code>Tuple[T, ...]</code></li> <li>Datum und Uhrzeit: <code>datetime</code>, <code>date</code>, <code>time</code></li> </ul>"},{"location":"fastapi/data_models/#erstellen-eines-einfachen-datenmodells","title":"Erstellen eines einfachen Datenmodells","text":"<p>Schauen wir uns ein einfaches Beispiel an: Wir m\u00f6chten eine API, die Benutzerdaten wie <code>name</code>, <code>email</code> und <code>age</code> verarbeitet. Mit Pydantic definieren wir die Struktur der zu verarbeitenden Daten.</p> <pre><code>from pydantic import BaseModel, EmailStr\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n    age: int\n</code></pre> <p>In diesem Modell wird <code>name</code> als <code>str</code>, <code>email</code> als <code>EmailStr</code> und <code>age</code> als <code>int</code> validiert. Die <code>EmailStr</code>-Typisierung stellt sicher, dass die Eingabe eine g\u00fcltige E-Mail-Adresse ist.</p>"},{"location":"fastapi/data_models/#aufgabe","title":"Aufgabe","text":"<p>Erweitere das <code>User</code>-Modell, indem du ein optionales Feld f\u00fcr <code>city</code> hinzuf\u00fcgst, das einen Standardwert hat, zum Beispiel <code>\"Unbekannt\"</code>. F\u00fcge au\u00dferdem ein Feld <code>is_active</code> hinzu, das einen <code>bool</code>-Wert erwartet und standardm\u00e4\u00dfig auf <code>True</code> gesetzt ist.</p>"},{"location":"fastapi/data_models/#modell-in-fastapi-einbinden","title":"Modell in FastAPI einbinden","text":"<p>Nachdem wir das Datenmodell mit Pydantic erstellt haben, wollen wir es in einer FastAPI-Anwendung verwenden. FastAPI erm\u00f6glicht es uns, Pydantic-Modelle direkt in Routen zu integrieren. So k\u00f6nnen wir sicherstellen, dass alle eingehenden Daten den definierten Anforderungen entsprechen.</p> <pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\nfrom typing import Optional\n\napp = FastAPI()\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n    age: int\n    city: Optional[str] = \"Unbekannt\"\n    is_active: bool = True\n\n@app.post(\"/users/\")\nasync def create_user(user: User):\n    return {\"user\": user}\n</code></pre> <p>In diesem Beispiel haben wir die Route <code>/users/</code> erstellt, die einen <code>POST</code>-Request erwartet. FastAPI \u00fcbernimmt die Validierung der Daten und gibt die g\u00fcltigen Daten als Antwort zur\u00fcck.</p>"},{"location":"fastapi/data_models/#aufgabe_1","title":"Aufgabe","text":"<p>Teste die <code>/users/</code>-Route mit einem API-Client wie Postman. Sende ein JSON-Objekt, das die Felder <code>name</code>, <code>email</code> und <code>age</code> enth\u00e4lt, und \u00fcberpr\u00fcfe, wie FastAPI das Modell validiert und zur\u00fcckgibt.</p>"},{"location":"fastapi/data_models/#validierung-und-fehlerbehandlung","title":"Validierung und Fehlerbehandlung","text":"<p>FastAPI und Pydantic bieten umfangreiche M\u00f6glichkeiten, Daten zu validieren. Wenn Daten nicht den Anforderungen entsprechen, gibt FastAPI eine detaillierte Fehlermeldung zur\u00fcck, die den Entwickler genau dar\u00fcber informiert, welcher Wert nicht g\u00fcltig ist.</p>"},{"location":"fastapi/data_models/#beispiel-fur-eine-validierung","title":"Beispiel f\u00fcr eine Validierung:","text":"<pre><code>from pydantic import BaseModel, Field\n\nclass User(BaseModel):\n    name: str = Field(..., min_length=2, max_length=50)\n    email: EmailStr\n    age: int = Field(..., gt=0, le=120)  # Altersbeschr\u00e4nkung\n    city: Optional[str] = \"Unbekannt\"\n    is_active: bool = True\n</code></pre> <p>In diesem Beispiel haben wir Einschr\u00e4nkungen f\u00fcr das Feld <code>name</code> (minimale und maximale L\u00e4nge) und <code>age</code> (gr\u00f6\u00dfer als 0 und maximal 120 Jahre) definiert.</p> <p>Wenn jemand beispielsweise eine ung\u00fcltige E-Mail-Adresse sendet oder das Alter zu hoch ist, gibt FastAPI eine Fehlerantwort zur\u00fcck.</p>"},{"location":"fastapi/data_models/#aufgabe_2","title":"Aufgabe","text":"<p>Teste das Modell in einer einfachen <code>POST</code>-Route, indem du es in FastAPI integrierst. \u00dcbermittle verschiedene <code>name</code>- und <code>age</code>-Werte und beobachte die Fehlermeldungen, die FastAPI automatisch generiert, wenn die Validierungen fehlschlagen.</p>"},{"location":"fastapi/data_models/#eigene-validierungen","title":"Eigene Validierungen","text":"<p>Pydantic erm\u00f6glicht es, benutzerdefinierte Validierungen hinzuzuf\u00fcgen. Wenn du komplexere Anforderungen hast, die \u00fcber die Standardvalidierung hinausgehen, kannst du eigene Validierungsfunktionen implementieren.</p> <p>Ein Beispiel f\u00fcr eine benutzerdefinierte Validierung:</p> <pre><code>from pydantic import validator\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n    age: int\n\n    @validator(\"name\")\n    def name_must_not_contain_numbers(cls, v):\n        if any(char.isdigit() for char in v):\n            raise ValueError(\"Name darf keine Zahlen enthalten\")\n        return v\n</code></pre> <p>In diesem Beispiel wird eine Validierung f\u00fcr das Feld <code>name</code> hinzugef\u00fcgt, die sicherstellt, dass der Name keine Zahlen enth\u00e4lt.</p>"},{"location":"fastapi/data_models/#aufgabe_3","title":"Aufgabe","text":"<p>Erweitere den <code>name</code>-Validator, sodass er auch sicherstellt, dass der Name keine Sonderzeichen enth\u00e4lt. Teste den Validator, indem du Namen wie \u201eJohn@Doe\u201c und \u201e123Peter\u201c eingibst und \u00fcberpr\u00fcfe die Fehlermeldungen.</p>"},{"location":"fastapi/first_steps/","title":"Erste Schritte mit FastAPI: HTTP-Routen","text":"<p>In diesem Abschnitt sehen wir uns die Grundlagen von HTTP-Routen und die Erstellung von API-Endpunkte in fastapi an. HTTP-Routen sind das Herzst\u00fcck jeder API. Sie definieren die verschiedenen Wege, auf denen Clients (wie Webbrowser oder mobile Apps) mit unserem Server kommunizieren k\u00f6nnen. FastAPI macht es besonders einfach, diese Routen zu erstellen und f\u00fcr verschiedene Anfragen zu konfigurieren.</p>"},{"location":"fastapi/first_steps/#unsere-erste-route-get","title":"Unsere erste Route: <code>GET</code>","text":"<p>Beginnen wir noch einmal mit einer grundlegenden Route, die eine Nachricht an den Client zur\u00fcckgibt. Der <code>GET</code>-Anfragetyp ist der einfachste und am h\u00e4ufigsten verwendete HTTP-Methodentyp \u2013 er ruft einfach Daten ab, ohne dass eine \u00c4nderung am Server oder in der Datenbank vorgenommen wird.</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def read_root():\n    return {\"message\": \"Hello, World!\"}\n</code></pre> <p>In diesem Beispiel erstellen wir eine FastAPI-Instanz namens <code>app</code>. Dann definieren wir eine <code>GET</code>-Route mit dem Endpunkt <code>/</code>, die einfach \u201eHello, World!\u201c zur\u00fcckgibt. Der <code>@app.get(\"/\")</code>-Dekorator sagt FastAPI, dass dieser Endpunkt auf <code>GET</code>-Anfragen wartet.</p>"},{"location":"fastapi/first_steps/#aufgabe","title":"Aufgabe","text":"<p>Starte den Server und rufe <code>http://127.0.0.1:8000/</code> in deinem Browser oder einem API-Client wie Postman auf. Siehst du die Nachricht? Experimentiere, indem du den Text \u00e4nderst. Teste, was passiert, wenn du den R\u00fcckgabewert ver\u00e4nderst \u2013 z. B. durch eine andere Nachricht oder eine Zahl.</p>"},{"location":"fastapi/first_steps/#parameter-in-der-url","title":"Parameter in der URL","text":"<p>Ein h\u00e4ufiges Szenario ist, dass wir Daten dynamisch basierend auf der Anfrage bereitstellen wollen. Nehmen wir an, wir m\u00f6chten eine Nachricht zur\u00fcckgeben, die den Namen des Benutzers enth\u00e4lt. Dazu f\u00fcgen wir einen URL-Parameter hinzu, der in die Route integriert wird.</p> <pre><code>@app.get(\"/hello/{name}\")\nasync def read_item(name: str):\n    return {\"message\": f\"Hello, {name}!\"}\n</code></pre> <p>Hier erstellen wir eine <code>GET</code>-Route mit einem dynamischen Segment <code>{name}</code>, das wir im Funktionsparameter <code>name</code> auffangen. Wenn wir <code>http://127.0.0.1:8000/hello/Alex</code> aufrufen, erhalten wir die Antwort: \u201eHello, Alex!\u201c</p>"},{"location":"fastapi/first_steps/#aufgabe_1","title":"Aufgabe","text":"<p>Erweitere die Route, um eine zweite Variable wie <code>age</code> oder <code>city</code> aufzunehmen. Erstelle eine Antwort, die beide Parameter in einem Begr\u00fc\u00dfungssatz verwendet. Teste verschiedene Namen und Werte, um zu sehen, wie FastAPI die Eingaben verarbeitet.</p>"},{"location":"fastapi/first_steps/#verwendung-von-http-methoden-post","title":"Verwendung von HTTP-Methoden: <code>POST</code>","text":"<p>Neben <code>GET</code> gibt es noch weitere HTTP-Methoden wie <code>POST</code>, <code>PUT</code> und <code>DELETE</code>, die alle unterschiedliche Zwecke erf\u00fcllen. <code>POST</code>-Anfragen werden typischerweise verwendet, um Daten an den Server zu senden, z. B. zum Erstellen eines neuen Eintrags.</p> <p>Angenommen, wir m\u00f6chten eine einfache Route erstellen, bei der der Benutzer eine Nachricht an den Server senden kann. Dabei nutzen wir die Methode <code>POST</code>, um die Nachricht vom Client entgegenzunehmen und eine Best\u00e4tigung zur\u00fcckzugeben.</p> <pre><code>from pydantic import BaseModel\n\nclass Message(BaseModel):\n    content: str\n\n@app.post(\"/send-message/\")\nasync def create_message(message: Message):\n    return {\"received_message\": message.content}\n</code></pre> <p>In diesem Beispiel erstellen wir ein Modell <code>Message</code> mit dem Attribut <code>content</code>, das eine Zeichenkette ist. Das <code>@app.post(\"/send-message/\")</code> zeigt FastAPI, dass dieser Endpunkt eine <code>POST</code>-Anfrage erwartet. Der Inhalt wird in Form eines JSON-Objekts vom Client gesendet und in das <code>message</code>-Objekt des Typs <code>Message</code> umgewandelt. Anschlie\u00dfend geben wir die empfangene Nachricht als Best\u00e4tigung zur\u00fcck.</p>"},{"location":"fastapi/first_steps/#aufgabe_2","title":"Aufgabe","text":"<p>Teste diese <code>POST</code>-Route mit einem API-Client wie Postman oder durch einen Browser-Extension. Sende eine JSON-Nachricht wie <code>{\"content\": \"Dies ist meine erste Nachricht\"}</code>. Experimentiere mit verschiedenen Nachrichten und \u00fcberpr\u00fcfe, wie FastAPI die Antwort generiert.</p>"},{"location":"fastapi/first_steps/#arbeiten-mit-query-parametern","title":"Arbeiten mit Query-Parametern","text":"<p>Neben Routenparametern und <code>POST</code>-Daten bietet FastAPI die M\u00f6glichkeit, Query-Parameter zu verwenden. Diese Art von Parametern befindet sich in der URL nach einem <code>?</code> und wird h\u00e4ufig f\u00fcr zus\u00e4tzliche, optionale Informationen genutzt. Beispielsweise m\u00f6chten wir eine Route erstellen, bei der der Benutzer seinen Namen als Query-Parameter senden kann, ohne ihn in der URL selbst zu definieren.</p> <pre><code>@app.get(\"/greet/\")\nasync def greet_user(name: str = \"Gast\"):\n    return {\"message\": f\"Hallo, {name}!\"}\n</code></pre> <p>In dieser Route verwenden wir den Query-Parameter <code>name</code>, der standardm\u00e4\u00dfig \u201eGast\u201c ist, falls kein Wert \u00fcbergeben wird. Wenn wir <code>http://127.0.0.1:8000/greet/?name=Lisa</code> aufrufen, erhalten wir die Antwort \u201eHallo, Lisa!\u201c.</p>"},{"location":"fastapi/first_steps/#aufgabe_3","title":"Aufgabe","text":"<p>Experimentiere mit der URL und dem <code>name</code>-Parameter. Probiere verschiedene Namen und teste, was passiert, wenn du den Parameter wegl\u00e4sst. Erweitere das Beispiel, indem du weitere optionale Query-Parameter hinzuf\u00fcgst, etwa <code>age</code> oder <code>city</code>.</p>"},{"location":"fastapi/intro/","title":"Einf\u00fchrung in FastAPI","text":""},{"location":"fastapi/intro/#was-ist-fastapi","title":"Was ist FastAPI?","text":"<p>FastAPI ist ein Web-Framework zur Entwicklung von APIs mit Python. Es wurde f\u00fcr den Einsatz in produktionskritischen Anwendungen entwickelt und zeichnet sich durch eine hohe Performance und einfache Handhabung aus.</p>"},{"location":"fastapi/intro/#kernmerkmale-von-fastapi","title":"Kernmerkmale von FastAPI","text":"<ul> <li>Automatische Dokumentation: FastAPI generiert automatisch interaktive API-Dokumentationen (Swagger UI, Redoc) auf Basis des OpenAPI-Standards.</li> <li>Asynchrone Verarbeitung: Unterst\u00fctzung f\u00fcr <code>async</code> und <code>await</code> erleichtert das Handling von asynchronen Aufgaben und macht FastAPI ideal f\u00fcr Anwendungen mit hohen Anforderungen an die Skalierbarkeit.</li> <li>Einfache Validierung: FastAPI verwendet Pydantic zur Validierung und Serialisierung von Daten, wodurch die Datenintegrit\u00e4t automatisch gesichert wird.</li> </ul>"},{"location":"fastapi/intro/#beispiel-einer-fastapi-anwendung","title":"Beispiel einer FastAPI-Anwendung","text":"<p>Hier eine grundlegende FastAPI-Anwendung, die einen \"Hello World\"-Endpunkt bereitstellt:</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello, World!\"}\n</code></pre>"},{"location":"fastapi/intro/#installation","title":"Installation","text":"<p>FastAPI kann \u00fcber <code>pip</code> installiert werden:</p> <pre><code>pip install fastapi[all]\n</code></pre> <p>Zus\u00e4tzlich wird ein ASGI-Server wie uvicorn ben\u00f6tigt, um die Anwendung zu starten:</p> <pre><code>pip install uvicorn\nuvicorn main:app --reload\n</code></pre>"},{"location":"fastapi/intro/#fastapi-vs-flask","title":"FastAPI vs. Flask","text":"<p>FastAPI und Flask sind beide beliebte Python-Frameworks zur API-Entwicklung, unterscheiden sich jedoch erheblich in ihrer Funktionsweise und ihrem Anwendungsbereich.</p>"},{"location":"fastapi/intro/#hauptunterschiede","title":"Hauptunterschiede","text":"Merkmal Flask FastAPI Asynchronit\u00e4t Unterst\u00fctzung nur mit zus\u00e4tzlichen Bibliotheken wie <code>flask-async</code> Eingebaute Unterst\u00fctzung f\u00fcr <code>async</code> und <code>await</code> Performance Moderate Geschwindigkeit Hohe Performance durch asynchrone Architektur Datenvalidierung Keine eingebaute Validierung, zus\u00e4tzliche Bibliotheken wie <code>marshmallow</code> erforderlich Integrierte Validierung mit Pydantic Dokumentation Keine automatische Dokumentation Automatische Generierung von Swagger UI und Redoc Ideal f\u00fcr Einfache APIs und Anwendungen APIs mit hoher Leistung und komplexen Datenvalidierungsanforderungen"},{"location":"fastapi/intro/#wann-man-fastapi-verwenden-sollte","title":"Wann man FastAPI verwenden sollte","text":"<ul> <li>Wenn hohe Performance und Skalierbarkeit gefordert sind.</li> <li>F\u00fcr APIs, die asynchrone Verarbeitung ben\u00f6tigen.</li> <li>Bei Projekten, in denen die automatische Dokumentation n\u00fctzlich ist.</li> </ul>"},{"location":"fastapi/intro/#wann-flask-geeigneter-ist","title":"Wann Flask geeigneter ist","text":"<ul> <li>Bei einfachen Anwendungen oder Prototypen, die nur grundlegende Funktionalit\u00e4ten ben\u00f6tigen.</li> <li>Wenn Asynchronit\u00e4t und Performance keine kritischen Anforderungen sind.</li> </ul>"},{"location":"fastapi/sqlmodel/","title":"Arbeiten mit SQLModel in FastAPI","text":"<p>SQLModel ist eine Bibliothek, die SQLAlchemy und Pydantic kombiniert. Sie erm\u00f6glicht es dir, Datenbankmodelle in FastAPI zu integrieren, ohne auf umfangreiche ORM-Definitionen verzichten zu m\u00fcssen. SQLModel baut auf SQLAlchemy auf und verwendet Pydantic zur Validierung der Daten, sodass du Datenbankmodelle erstellen und gleichzeitig die Vorteile der Datenvalidierung von Pydantic nutzen kannst.</p>"},{"location":"fastapi/sqlmodel/#was-ist-sqlmodel","title":"Was ist SQLModel?","text":"<p>SQLModel ist eine Bibliothek, die es erm\u00f6glicht, SQL-Datenbanken in FastAPI-Anwendungen zu integrieren. Sie stellt eine einfache Schnittstelle zur Verf\u00fcgung, die es dir erm\u00f6glicht, sowohl Datenbankmodelle zu definieren als auch mit der Datenbank zu interagieren \u2013 alles in einer sauberen und einheitlichen API.</p> <p>SQLModel erm\u00f6glicht die Definition von Pydantic-Modellen, die gleichzeitig auch Datenbankmodelle sind. Das bedeutet, dass du nur ein Modell schreiben musst, um sowohl mit der Datenbank als auch mit FastAPI zu arbeiten.</p>"},{"location":"fastapi/sqlmodel/#installation","title":"Installation","text":"<pre><code>pip install sqlmodel\n</code></pre>"},{"location":"fastapi/sqlmodel/#erstellen-eines-einfachen-sqlmodel-datenmodells","title":"Erstellen eines einfachen SQLModel-Datenmodells","text":"<p>Ein SQLModel-Datenmodell ist sehr \u00e4hnlich wie ein Pydantic-Modell, aber mit zus\u00e4tzlichen SQLAlchemy-Features wie <code>Field</code> und <code>Relationship</code> f\u00fcr die Datenbankinteraktion. </p> <pre><code>from sqlmodel import Field, SQLModel\n\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n    email: str\n    age: int\n</code></pre> <p>In diesem Beispiel haben wir ein einfaches User-Modell erstellt, das die Felder <code>id</code>, <code>name</code>, <code>email</code> und <code>age</code> enth\u00e4lt. Das <code>table=True</code>-Attribut signalisiert, dass dieses Modell eine Tabelle in der Datenbank repr\u00e4sentiert.</p>"},{"location":"fastapi/sqlmodel/#aufgabe","title":"Aufgabe","text":"<p>Erstelle ein weiteres Datenmodell, das <code>Product</code>-Daten mit den Feldern <code>name</code>, <code>price</code> und <code>description</code> speichert. Vergiss nicht, die <code>id</code> als Prim\u00e4rschl\u00fcssel hinzuzuf\u00fcgen.</p>"},{"location":"fastapi/sqlmodel/#datenbankverbindungen-und-sessions","title":"Datenbankverbindungen und Sessions","text":"<p>Eine der wichtigsten Aufgaben beim Arbeiten mit SQLModel ist die Verbindung zur Datenbank und die Verwaltung von Sessions, um Transaktionen durchzuf\u00fchren. SQLModel baut auf SQLAlchemy auf, sodass wir die gleiche Methode verwenden, um die Verbindung zur Datenbank herzustellen.</p>"},{"location":"fastapi/sqlmodel/#verbindung-zur-datenbank-herstellen","title":"Verbindung zur Datenbank herstellen","text":"<p>Du kannst SQLModel mit einer SQLite-Datenbank oder einer anderen unterst\u00fctzten Datenbank wie PostgreSQL oder MySQL verwenden. Hier ist ein einfaches Beispiel f\u00fcr die Verbindung zu einer SQLite-Datenbank:</p> <pre><code>from sqlmodel import create_engine, Session\n\n# Erstelle die Verbindung zur SQLite-Datenbank\nengine = create_engine(\"sqlite:///database.db\")\n\n# Erstelle die Tabellen in der Datenbank (falls sie noch nicht existieren)\nSQLModel.metadata.create_all(engine)\n</code></pre>"},{"location":"fastapi/sqlmodel/#arbeiten-mit-sessions","title":"Arbeiten mit Sessions","text":"<p>Um mit der Datenbank zu interagieren, musst du eine Session erstellen, die es dir erm\u00f6glicht, Datens\u00e4tze zu lesen, zu schreiben und zu aktualisieren.</p> <pre><code>from sqlmodel import Session\n\n# \u00d6ffne eine Session, um mit der Datenbank zu interagieren\nwith Session(engine) as session:\n    # Beispiel: Hinzuf\u00fcgen eines neuen Benutzers\n    user = User(name=\"John Doe\", email=\"johndoe@example.com\", age=30)\n    session.add(user)\n    session.commit()\n</code></pre>"},{"location":"fastapi/sqlmodel/#aufgabe_1","title":"Aufgabe","text":"<p>Erstelle eine neue <code>Product</code>-Instanz, f\u00fcge sie zur Datenbank hinzu und best\u00e4tige die Transaktion mit <code>session.commit()</code>.</p>"},{"location":"fastapi/sqlmodel/#crud-operationen-mit-sqlmodel","title":"CRUD-Operationen mit SQLModel","text":"<p>SQLModel macht es einfach, grundlegende CRUD-Operationen (Create, Read, Update, Delete) auf Datenbanken durchzuf\u00fchren. Nachdem du die Datenbankverbindung und das Modell eingerichtet hast, kannst du Datens\u00e4tze einfach erstellen und abfragen.</p>"},{"location":"fastapi/sqlmodel/#erstellen-eines-datensatzes-create","title":"Erstellen eines Datensatzes (Create)","text":"<pre><code>with Session(engine) as session:\n    new_user = User(name=\"Jane Doe\", email=\"janedoe@example.com\", age=25)\n    session.add(new_user)\n    session.commit()\n</code></pre>"},{"location":"fastapi/sqlmodel/#lesen-von-datensatzen-read","title":"Lesen von Datens\u00e4tzen (Read)","text":"<pre><code>with Session(engine) as session:\n    user = session.query(User).filter(User.name == \"Jane Doe\").first()\n    print(user)\n</code></pre>"},{"location":"fastapi/sqlmodel/#aktualisieren-von-datensatzen-update","title":"Aktualisieren von Datens\u00e4tzen (Update)","text":"<pre><code>with Session(engine) as session:\n    user = session.query(User).filter(User.name == \"Jane Doe\").first()\n    if user:\n        user.age = 26\n        session.commit()\n</code></pre>"},{"location":"fastapi/sqlmodel/#loschen-von-datensatzen-delete","title":"L\u00f6schen von Datens\u00e4tzen (Delete)","text":"<pre><code>with Session(engine) as session:\n    user = session.query(User).filter(User.name == \"Jane Doe\").first()\n    if user:\n        session.delete(user)\n        session.commit()\n</code></pre>"},{"location":"fastapi/sqlmodel/#aufgabe_2","title":"Aufgabe","text":"<p>Erweitere das <code>User</code>-Modell um ein <code>address</code>-Feld und f\u00fchre eine <code>UPDATE</code>-Operation durch, um die Adresse eines bestimmten Benutzers zu \u00e4ndern.</p>"},{"location":"fastapi/sqlmodel/#integration-von-sqlmodel-mit-fastapi","title":"Integration von SQLModel mit FastAPI","text":"<p>Ein gro\u00dfer Vorteil von SQLModel ist, dass es nahtlos mit FastAPI integriert werden kann. Du kannst SQLModel-Modelle direkt in deine FastAPI-Routen einbinden, um API-Endpunkte zu erstellen, die mit der Datenbank interagieren.</p>"},{"location":"fastapi/sqlmodel/#beispiel-fur-einen-fastapi-endpunkt-mit-sqlmodel","title":"Beispiel f\u00fcr einen FastAPI-Endpunkt mit SQLModel","text":"<pre><code>from fastapi import FastAPI\nfrom sqlmodel import Session, select\n\napp = FastAPI()\n\n@app.post(\"/users/\")\nasync def create_user(user: User):\n    with Session(engine) as session:\n        session.add(user)\n        session.commit()\n    return {\"user\": user}\n</code></pre> <p>In diesem Beispiel haben wir eine <code>POST</code>-Route erstellt, die ein <code>User</code>-Objekt entgegennimmt und es in die Datenbank speichert.</p>"},{"location":"fastapi/sqlmodel/#aufgabe_3","title":"Aufgabe","text":"<p>Erstelle eine <code>GET</code>-Route, die alle Benutzer aus der Datenbank abruft und zur\u00fcckgibt.</p>"},{"location":"fastapi/task/","title":"Vorhersage des Einkommens basierend auf dem Adult Income Dataset","text":"<p>In dieser Aufgabe wirst du das Adult Income Dataset verwenden, um ein einfaches API-Modell zu erstellen, das die Wahrscheinlichkeit vorhersagt, ob jemand mehr als 50.000 USD j\u00e4hrlich verdient, basierend auf verschiedenen demografischen Merkmalen. Du wirst SQLModel f\u00fcr das Speichern der Daten in einer Datenbank und FastAPI f\u00fcr die API-Erstellung verwenden.</p>"},{"location":"fastapi/task/#aufgabe-1-datenvorbereitung-und-verstandnis","title":"Aufgabe 1: Datenvorbereitung und -verst\u00e4ndnis","text":"<p>Lade das Adult Income Dataset herunter und analysiere die Spalten. Erstelle ein Streamlit Dashboard oder Jupyter Notebook, um den Datensatz visuell aufzubereiten. Der Datensatz enth\u00e4lt folgende Merkmale:</p> <ul> <li><code>age</code>: Alter der Person</li> <li><code>workclass</code>: Arbeitsverh\u00e4ltnis (z.B. privat, \u00f6ffentlich)</li> <li><code>fnlwgt</code>: Gewicht (repr\u00e4sentiert die Anzahl der Menschen, die in der Stichprobe repr\u00e4sentiert sind)</li> <li><code>education</code>: H\u00f6chster Bildungsabschluss</li> <li><code>education-num</code>: Bildung in numerischer Form</li> <li><code>marital-status</code>: Familienstand</li> <li><code>occupation</code>: Beruf</li> <li><code>relationship</code>: Beziehung zum Haushaltsvorstand</li> <li><code>race</code>: Rasse</li> <li><code>sex</code>: Geschlecht</li> <li><code>capital-gain</code>: Kapitalgewinne</li> <li><code>capital-loss</code>: Kapitalverlust</li> <li><code>hours-per-week</code>: Arbeitsstunden pro Woche</li> <li><code>native-country</code>: Geburtsland</li> <li><code>income</code>: Einkommen (mehr als 50K oder weniger)</li> </ul>"},{"location":"fastapi/task/#aufgabe-2-erstellen-eines-sqlmodel-datenmodells","title":"Aufgabe 2: Erstellen eines SQLModel-Datenmodells","text":"<p>Erstelle ein <code>User</code>-Datenmodell mit SQLModel, das die oben genannten Merkmale repr\u00e4sentiert. Definiere auch den Typ der Merkmale (z. B. <code>age</code> als Integer, <code>education</code> als String). </p>"},{"location":"fastapi/task/#aufgabe-3-api-erstellung-mit-fastapi","title":"Aufgabe 3: API-Erstellung mit FastAPI","text":"<p>Erstelle eine FastAPI-Anwendung, die folgende Funktionalit\u00e4ten bietet:</p> <ol> <li> <p>Daten hinzuf\u00fcgen: Erstelle eine POST-Route, die es erm\u00f6glicht, neue Benutzerdaten hinzuzuf\u00fcgen. Die Route sollte alle Merkmale des Datensatzes akzeptieren.</p> </li> <li> <p>Daten abfragen: Erstelle eine GET-Route, um alle gespeicherten Benutzerdaten abzurufen.</p> </li> <li> <p>Einkommensvorhersage: Erstelle eine weitere POST-Route, die basierend auf den eingegebenen demografischen Merkmalen vorhersagt, ob das Einkommen mehr als 50.000 USD betr\u00e4gt oder nicht. Diese Route sollte ein Modell wie z. B. einen einfachen Entscheidungsbaum verwenden (der zuvor auf den Daten trainiert wurde), um die Vorhersage zu treffen.</p> </li> </ol>"},{"location":"fastapi/task/#aufgabe-4-testen-der-api-mit-postman-oder-einem-anderen-api-client","title":"Aufgabe 4: Testen der API mit Postman oder einem anderen API-Client","text":"<ol> <li> <p>Daten hinzuf\u00fcgen: Verwende die POST-Route <code>/add-user</code> (oder eine benannte Route) zum Hinzuf\u00fcgen eines neuen Datensatzes.</p> </li> <li> <p>Daten abfragen: Verwende die GET-Route <code>/users</code>, um alle gespeicherten Benutzer abzurufen.</p> </li> <li> <p>Einkommensvorhersage: Teste die <code>/predict-income/</code>-Route, indem du verschiedene Werte f\u00fcr <code>age</code>, <code>hours-per-week</code> und andere Merkmale eingibst.</p> </li> </ol>"},{"location":"fastapi/task/#aufgabe-5-zusatz-analyse-und-modellverbesserung","title":"Aufgabe 5 (Zusatz): Analyse und Modellverbesserung","text":"<p>Nachdem du die API erstellt hast, analysiere die Vorhersageergebnisse und \u00fcberlege, wie du das Modell verbessern kannst</p>"}]}