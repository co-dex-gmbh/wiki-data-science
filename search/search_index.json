{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"fastapi/data_models/","text":"Datenmodelle mit Pydantic in FastAPI Datenmodelle sind ein wesentlicher Bestandteil von APIs, da sie definieren, welche Art von Daten zwischen dem Server und den Clients ausgetauscht werden kann. In FastAPI \u00fcbernimmt die Bibliothek Pydantic diese Aufgabe, indem sie Python-Datenstrukturen in valide JSON-Objekte verwandelt. Pydantic bietet starke Validierungs- und Typisierungsfunktionen und erm\u00f6glicht es uns, Daten mit minimalem Aufwand zu strukturieren und zu validieren. Warum Pydantic? Pydantic ist eine zentrale Bibliothek in FastAPI, da sie eine einfache M\u00f6glichkeit bietet, Daten zu validieren und zu serialisieren. Mit Pydantic k\u00f6nnen wir sicherstellen, dass die Daten, die von einem Client gesendet werden oder an diesen zur\u00fcckgegeben werden, den gew\u00fcnschten Typen entsprechen. Dies verringert potenzielle Fehler und macht den Code robuster und lesbarer. Typisierung und Validierung Pydantic nutzt Python\u2019s Typannotation, um die Struktur der Daten zu definieren und die Validierung basierend auf den angegebenen Datentypen durchzuf\u00fchren. Wenn du also ein Modell mit Feldern wie str , int oder EmailStr erstellst, stellt Pydantic sicher, dass die Daten den entsprechenden Typen entsprechen. Ein Beispiel f\u00fcr eine einfache Typisierung: from pydantic import BaseModel, EmailStr class User(BaseModel): name: str email: EmailStr age: int Hier sorgt Pydantic daf\u00fcr, dass die email -Adresse als g\u00fcltige E-Mail-Adresse formatiert ist, w\u00e4hrend der Name ein String und das Alter eine Ganzzahl ist. Unterst\u00fctzte Datentypen Pydantic unterst\u00fctzt eine breite Palette von Datentypen, um unterschiedliche Anwendungsf\u00e4lle abzudecken. Zu den wichtigsten geh\u00f6ren: Primitive Typen : str , int , float , bool Spezielle Typen : EmailStr , UUID , IPv4 , IPv6 Optionale Felder : Optional[T] , um Felder als optional zu kennzeichnen Listen und Tupel : List[T] , Tuple[T, ...] Datum und Uhrzeit : datetime , date , time Erstellen eines einfachen Datenmodells Schauen wir uns ein einfaches Beispiel an: Wir m\u00f6chten eine API, die Benutzerdaten wie name , email und age verarbeitet. Mit Pydantic definieren wir die Struktur der zu verarbeitenden Daten. from pydantic import BaseModel, EmailStr class User(BaseModel): name: str email: EmailStr age: int In diesem Modell wird name als str , email als EmailStr und age als int validiert. Die EmailStr -Typisierung stellt sicher, dass die Eingabe eine g\u00fcltige E-Mail-Adresse ist. Aufgabe Erweitere das User -Modell, indem du ein optionales Feld f\u00fcr city hinzuf\u00fcgst, das einen Standardwert hat, zum Beispiel \"Unbekannt\" . F\u00fcge au\u00dferdem ein Feld is_active hinzu, das einen bool -Wert erwartet und standardm\u00e4\u00dfig auf True gesetzt ist. Modell in FastAPI einbinden Nachdem wir das Datenmodell mit Pydantic erstellt haben, wollen wir es in einer FastAPI-Anwendung verwenden. FastAPI erm\u00f6glicht es uns, Pydantic-Modelle direkt in Routen zu integrieren. So k\u00f6nnen wir sicherstellen, dass alle eingehenden Daten den definierten Anforderungen entsprechen. from fastapi import FastAPI from pydantic import BaseModel, EmailStr from typing import Optional app = FastAPI() class User(BaseModel): name: str email: EmailStr age: int city: Optional[str] = \"Unbekannt\" is_active: bool = True @app.post(\"/users/\") async def create_user(user: User): return {\"user\": user} In diesem Beispiel haben wir die Route /users/ erstellt, die einen POST -Request erwartet. FastAPI \u00fcbernimmt die Validierung der Daten und gibt die g\u00fcltigen Daten als Antwort zur\u00fcck. Aufgabe Teste die /users/ -Route mit einem API-Client wie Postman. Sende ein JSON-Objekt, das die Felder name , email und age enth\u00e4lt, und \u00fcberpr\u00fcfe, wie FastAPI das Modell validiert und zur\u00fcckgibt. Validierung und Fehlerbehandlung FastAPI und Pydantic bieten umfangreiche M\u00f6glichkeiten, Daten zu validieren. Wenn Daten nicht den Anforderungen entsprechen, gibt FastAPI eine detaillierte Fehlermeldung zur\u00fcck, die den Entwickler genau dar\u00fcber informiert, welcher Wert nicht g\u00fcltig ist. Beispiel f\u00fcr eine Validierung: from pydantic import BaseModel, Field class User(BaseModel): name: str = Field(..., min_length=2, max_length=50) email: EmailStr age: int = Field(..., gt=0, le=120) # Altersbeschr\u00e4nkung city: Optional[str] = \"Unbekannt\" is_active: bool = True In diesem Beispiel haben wir Einschr\u00e4nkungen f\u00fcr das Feld name (minimale und maximale L\u00e4nge) und age (gr\u00f6\u00dfer als 0 und maximal 120 Jahre) definiert. Wenn jemand beispielsweise eine ung\u00fcltige E-Mail-Adresse sendet oder das Alter zu hoch ist, gibt FastAPI eine Fehlerantwort zur\u00fcck. Aufgabe Teste das Modell in einer einfachen POST -Route, indem du es in FastAPI integrierst. \u00dcbermittle verschiedene name - und age -Werte und beobachte die Fehlermeldungen, die FastAPI automatisch generiert, wenn die Validierungen fehlschlagen. Eigene Validierungen Pydantic erm\u00f6glicht es, benutzerdefinierte Validierungen hinzuzuf\u00fcgen. Wenn du komplexere Anforderungen hast, die \u00fcber die Standardvalidierung hinausgehen, kannst du eigene Validierungsfunktionen implementieren. Ein Beispiel f\u00fcr eine benutzerdefinierte Validierung: from pydantic import validator class User(BaseModel): name: str email: EmailStr age: int @validator(\"name\") def name_must_not_contain_numbers(cls, v): if any(char.isdigit() for char in v): raise ValueError(\"Name darf keine Zahlen enthalten\") return v In diesem Beispiel wird eine Validierung f\u00fcr das Feld name hinzugef\u00fcgt, die sicherstellt, dass der Name keine Zahlen enth\u00e4lt. Aufgabe Erweitere den name -Validator, sodass er auch sicherstellt, dass der Name keine Sonderzeichen enth\u00e4lt. Teste den Validator, indem du Namen wie \u201eJohn@Doe\u201c und \u201e123Peter\u201c eingibst und \u00fcberpr\u00fcfe die Fehlermeldungen.","title":"Datenmodelle mit Pydantic in FastAPI"},{"location":"fastapi/data_models/#datenmodelle-mit-pydantic-in-fastapi","text":"Datenmodelle sind ein wesentlicher Bestandteil von APIs, da sie definieren, welche Art von Daten zwischen dem Server und den Clients ausgetauscht werden kann. In FastAPI \u00fcbernimmt die Bibliothek Pydantic diese Aufgabe, indem sie Python-Datenstrukturen in valide JSON-Objekte verwandelt. Pydantic bietet starke Validierungs- und Typisierungsfunktionen und erm\u00f6glicht es uns, Daten mit minimalem Aufwand zu strukturieren und zu validieren.","title":"Datenmodelle mit Pydantic in FastAPI"},{"location":"fastapi/data_models/#warum-pydantic","text":"Pydantic ist eine zentrale Bibliothek in FastAPI, da sie eine einfache M\u00f6glichkeit bietet, Daten zu validieren und zu serialisieren. Mit Pydantic k\u00f6nnen wir sicherstellen, dass die Daten, die von einem Client gesendet werden oder an diesen zur\u00fcckgegeben werden, den gew\u00fcnschten Typen entsprechen. Dies verringert potenzielle Fehler und macht den Code robuster und lesbarer.","title":"Warum Pydantic?"},{"location":"fastapi/data_models/#typisierung-und-validierung","text":"Pydantic nutzt Python\u2019s Typannotation, um die Struktur der Daten zu definieren und die Validierung basierend auf den angegebenen Datentypen durchzuf\u00fchren. Wenn du also ein Modell mit Feldern wie str , int oder EmailStr erstellst, stellt Pydantic sicher, dass die Daten den entsprechenden Typen entsprechen. Ein Beispiel f\u00fcr eine einfache Typisierung: from pydantic import BaseModel, EmailStr class User(BaseModel): name: str email: EmailStr age: int Hier sorgt Pydantic daf\u00fcr, dass die email -Adresse als g\u00fcltige E-Mail-Adresse formatiert ist, w\u00e4hrend der Name ein String und das Alter eine Ganzzahl ist.","title":"Typisierung und Validierung"},{"location":"fastapi/data_models/#unterstutzte-datentypen","text":"Pydantic unterst\u00fctzt eine breite Palette von Datentypen, um unterschiedliche Anwendungsf\u00e4lle abzudecken. Zu den wichtigsten geh\u00f6ren: Primitive Typen : str , int , float , bool Spezielle Typen : EmailStr , UUID , IPv4 , IPv6 Optionale Felder : Optional[T] , um Felder als optional zu kennzeichnen Listen und Tupel : List[T] , Tuple[T, ...] Datum und Uhrzeit : datetime , date , time","title":"Unterst\u00fctzte Datentypen"},{"location":"fastapi/data_models/#erstellen-eines-einfachen-datenmodells","text":"Schauen wir uns ein einfaches Beispiel an: Wir m\u00f6chten eine API, die Benutzerdaten wie name , email und age verarbeitet. Mit Pydantic definieren wir die Struktur der zu verarbeitenden Daten. from pydantic import BaseModel, EmailStr class User(BaseModel): name: str email: EmailStr age: int In diesem Modell wird name als str , email als EmailStr und age als int validiert. Die EmailStr -Typisierung stellt sicher, dass die Eingabe eine g\u00fcltige E-Mail-Adresse ist.","title":"Erstellen eines einfachen Datenmodells"},{"location":"fastapi/data_models/#aufgabe","text":"Erweitere das User -Modell, indem du ein optionales Feld f\u00fcr city hinzuf\u00fcgst, das einen Standardwert hat, zum Beispiel \"Unbekannt\" . F\u00fcge au\u00dferdem ein Feld is_active hinzu, das einen bool -Wert erwartet und standardm\u00e4\u00dfig auf True gesetzt ist.","title":"Aufgabe"},{"location":"fastapi/data_models/#modell-in-fastapi-einbinden","text":"Nachdem wir das Datenmodell mit Pydantic erstellt haben, wollen wir es in einer FastAPI-Anwendung verwenden. FastAPI erm\u00f6glicht es uns, Pydantic-Modelle direkt in Routen zu integrieren. So k\u00f6nnen wir sicherstellen, dass alle eingehenden Daten den definierten Anforderungen entsprechen. from fastapi import FastAPI from pydantic import BaseModel, EmailStr from typing import Optional app = FastAPI() class User(BaseModel): name: str email: EmailStr age: int city: Optional[str] = \"Unbekannt\" is_active: bool = True @app.post(\"/users/\") async def create_user(user: User): return {\"user\": user} In diesem Beispiel haben wir die Route /users/ erstellt, die einen POST -Request erwartet. FastAPI \u00fcbernimmt die Validierung der Daten und gibt die g\u00fcltigen Daten als Antwort zur\u00fcck.","title":"Modell in FastAPI einbinden"},{"location":"fastapi/data_models/#aufgabe_1","text":"Teste die /users/ -Route mit einem API-Client wie Postman. Sende ein JSON-Objekt, das die Felder name , email und age enth\u00e4lt, und \u00fcberpr\u00fcfe, wie FastAPI das Modell validiert und zur\u00fcckgibt.","title":"Aufgabe"},{"location":"fastapi/data_models/#validierung-und-fehlerbehandlung","text":"FastAPI und Pydantic bieten umfangreiche M\u00f6glichkeiten, Daten zu validieren. Wenn Daten nicht den Anforderungen entsprechen, gibt FastAPI eine detaillierte Fehlermeldung zur\u00fcck, die den Entwickler genau dar\u00fcber informiert, welcher Wert nicht g\u00fcltig ist.","title":"Validierung und Fehlerbehandlung"},{"location":"fastapi/data_models/#beispiel-fur-eine-validierung","text":"from pydantic import BaseModel, Field class User(BaseModel): name: str = Field(..., min_length=2, max_length=50) email: EmailStr age: int = Field(..., gt=0, le=120) # Altersbeschr\u00e4nkung city: Optional[str] = \"Unbekannt\" is_active: bool = True In diesem Beispiel haben wir Einschr\u00e4nkungen f\u00fcr das Feld name (minimale und maximale L\u00e4nge) und age (gr\u00f6\u00dfer als 0 und maximal 120 Jahre) definiert. Wenn jemand beispielsweise eine ung\u00fcltige E-Mail-Adresse sendet oder das Alter zu hoch ist, gibt FastAPI eine Fehlerantwort zur\u00fcck.","title":"Beispiel f\u00fcr eine Validierung:"},{"location":"fastapi/data_models/#aufgabe_2","text":"Teste das Modell in einer einfachen POST -Route, indem du es in FastAPI integrierst. \u00dcbermittle verschiedene name - und age -Werte und beobachte die Fehlermeldungen, die FastAPI automatisch generiert, wenn die Validierungen fehlschlagen.","title":"Aufgabe"},{"location":"fastapi/data_models/#eigene-validierungen","text":"Pydantic erm\u00f6glicht es, benutzerdefinierte Validierungen hinzuzuf\u00fcgen. Wenn du komplexere Anforderungen hast, die \u00fcber die Standardvalidierung hinausgehen, kannst du eigene Validierungsfunktionen implementieren. Ein Beispiel f\u00fcr eine benutzerdefinierte Validierung: from pydantic import validator class User(BaseModel): name: str email: EmailStr age: int @validator(\"name\") def name_must_not_contain_numbers(cls, v): if any(char.isdigit() for char in v): raise ValueError(\"Name darf keine Zahlen enthalten\") return v In diesem Beispiel wird eine Validierung f\u00fcr das Feld name hinzugef\u00fcgt, die sicherstellt, dass der Name keine Zahlen enth\u00e4lt.","title":"Eigene Validierungen"},{"location":"fastapi/data_models/#aufgabe_3","text":"Erweitere den name -Validator, sodass er auch sicherstellt, dass der Name keine Sonderzeichen enth\u00e4lt. Teste den Validator, indem du Namen wie \u201eJohn@Doe\u201c und \u201e123Peter\u201c eingibst und \u00fcberpr\u00fcfe die Fehlermeldungen.","title":"Aufgabe"},{"location":"fastapi/first_steps/","text":"Erste Schritte mit FastAPI: HTTP-Routen In diesem Abschnitt sehen wir uns die Grundlagen von HTTP-Routen und die Erstellung von API-Endpunkte in fastapi an. HTTP-Routen sind das Herzst\u00fcck jeder API. Sie definieren die verschiedenen Wege, auf denen Clients (wie Webbrowser oder mobile Apps) mit unserem Server kommunizieren k\u00f6nnen. FastAPI macht es besonders einfach, diese Routen zu erstellen und f\u00fcr verschiedene Anfragen zu konfigurieren. Unsere erste Route: GET Beginnen wir noch einmal mit einer grundlegenden Route, die eine Nachricht an den Client zur\u00fcckgibt. Der GET -Anfragetyp ist der einfachste und am h\u00e4ufigsten verwendete HTTP-Methodentyp \u2013 er ruft einfach Daten ab, ohne dass eine \u00c4nderung am Server oder in der Datenbank vorgenommen wird. from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def read_root(): return {\"message\": \"Hello, World!\"} In diesem Beispiel erstellen wir eine FastAPI-Instanz namens app . Dann definieren wir eine GET -Route mit dem Endpunkt / , die einfach \u201eHello, World!\u201c zur\u00fcckgibt. Der @app.get(\"/\") -Dekorator sagt FastAPI, dass dieser Endpunkt auf GET -Anfragen wartet. Aufgabe Starte den Server und rufe http://127.0.0.1:8000/ in deinem Browser oder einem API-Client wie Postman auf. Siehst du die Nachricht? Experimentiere, indem du den Text \u00e4nderst. Teste, was passiert, wenn du den R\u00fcckgabewert ver\u00e4nderst \u2013 z. B. durch eine andere Nachricht oder eine Zahl. Parameter in der URL Ein h\u00e4ufiges Szenario ist, dass wir Daten dynamisch basierend auf der Anfrage bereitstellen wollen. Nehmen wir an, wir m\u00f6chten eine Nachricht zur\u00fcckgeben, die den Namen des Benutzers enth\u00e4lt. Dazu f\u00fcgen wir einen URL-Parameter hinzu, der in die Route integriert wird. @app.get(\"/hello/{name}\") async def read_item(name: str): return {\"message\": f\"Hello, {name}!\"} Hier erstellen wir eine GET -Route mit einem dynamischen Segment {name} , das wir im Funktionsparameter name auffangen. Wenn wir http://127.0.0.1:8000/hello/Alex aufrufen, erhalten wir die Antwort: \u201eHello, Alex!\u201c Aufgabe Erweitere die Route, um eine zweite Variable wie age oder city aufzunehmen. Erstelle eine Antwort, die beide Parameter in einem Begr\u00fc\u00dfungssatz verwendet. Teste verschiedene Namen und Werte, um zu sehen, wie FastAPI die Eingaben verarbeitet. Verwendung von HTTP-Methoden: POST Neben GET gibt es noch weitere HTTP-Methoden wie POST , PUT und DELETE , die alle unterschiedliche Zwecke erf\u00fcllen. POST -Anfragen werden typischerweise verwendet, um Daten an den Server zu senden, z. B. zum Erstellen eines neuen Eintrags. Angenommen, wir m\u00f6chten eine einfache Route erstellen, bei der der Benutzer eine Nachricht an den Server senden kann. Dabei nutzen wir die Methode POST , um die Nachricht vom Client entgegenzunehmen und eine Best\u00e4tigung zur\u00fcckzugeben. from pydantic import BaseModel class Message(BaseModel): content: str @app.post(\"/send-message/\") async def create_message(message: Message): return {\"received_message\": message.content} In diesem Beispiel erstellen wir ein Modell Message mit dem Attribut content , das eine Zeichenkette ist. Das @app.post(\"/send-message/\") zeigt FastAPI, dass dieser Endpunkt eine POST -Anfrage erwartet. Der Inhalt wird in Form eines JSON-Objekts vom Client gesendet und in das message -Objekt des Typs Message umgewandelt. Anschlie\u00dfend geben wir die empfangene Nachricht als Best\u00e4tigung zur\u00fcck. Aufgabe Teste diese POST -Route mit einem API-Client wie Postman oder durch einen Browser-Extension. Sende eine JSON-Nachricht wie {\"content\": \"Dies ist meine erste Nachricht\"} . Experimentiere mit verschiedenen Nachrichten und \u00fcberpr\u00fcfe, wie FastAPI die Antwort generiert. Arbeiten mit Query-Parametern Neben Routenparametern und POST -Daten bietet FastAPI die M\u00f6glichkeit, Query-Parameter zu verwenden. Diese Art von Parametern befindet sich in der URL nach einem ? und wird h\u00e4ufig f\u00fcr zus\u00e4tzliche, optionale Informationen genutzt. Beispielsweise m\u00f6chten wir eine Route erstellen, bei der der Benutzer seinen Namen als Query-Parameter senden kann, ohne ihn in der URL selbst zu definieren. @app.get(\"/greet/\") async def greet_user(name: str = \"Gast\"): return {\"message\": f\"Hallo, {name}!\"} In dieser Route verwenden wir den Query-Parameter name , der standardm\u00e4\u00dfig \u201eGast\u201c ist, falls kein Wert \u00fcbergeben wird. Wenn wir http://127.0.0.1:8000/greet/?name=Lisa aufrufen, erhalten wir die Antwort \u201eHallo, Lisa!\u201c. Aufgabe Experimentiere mit der URL und dem name -Parameter. Probiere verschiedene Namen und teste, was passiert, wenn du den Parameter wegl\u00e4sst. Erweitere das Beispiel, indem du weitere optionale Query-Parameter hinzuf\u00fcgst, etwa age oder city .","title":"Erste Schritte mit FastAPI: HTTP-Routen"},{"location":"fastapi/first_steps/#erste-schritte-mit-fastapi-http-routen","text":"In diesem Abschnitt sehen wir uns die Grundlagen von HTTP-Routen und die Erstellung von API-Endpunkte in fastapi an. HTTP-Routen sind das Herzst\u00fcck jeder API. Sie definieren die verschiedenen Wege, auf denen Clients (wie Webbrowser oder mobile Apps) mit unserem Server kommunizieren k\u00f6nnen. FastAPI macht es besonders einfach, diese Routen zu erstellen und f\u00fcr verschiedene Anfragen zu konfigurieren.","title":"Erste Schritte mit FastAPI: HTTP-Routen"},{"location":"fastapi/first_steps/#unsere-erste-route-get","text":"Beginnen wir noch einmal mit einer grundlegenden Route, die eine Nachricht an den Client zur\u00fcckgibt. Der GET -Anfragetyp ist der einfachste und am h\u00e4ufigsten verwendete HTTP-Methodentyp \u2013 er ruft einfach Daten ab, ohne dass eine \u00c4nderung am Server oder in der Datenbank vorgenommen wird. from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def read_root(): return {\"message\": \"Hello, World!\"} In diesem Beispiel erstellen wir eine FastAPI-Instanz namens app . Dann definieren wir eine GET -Route mit dem Endpunkt / , die einfach \u201eHello, World!\u201c zur\u00fcckgibt. Der @app.get(\"/\") -Dekorator sagt FastAPI, dass dieser Endpunkt auf GET -Anfragen wartet.","title":"Unsere erste Route: GET"},{"location":"fastapi/first_steps/#aufgabe","text":"Starte den Server und rufe http://127.0.0.1:8000/ in deinem Browser oder einem API-Client wie Postman auf. Siehst du die Nachricht? Experimentiere, indem du den Text \u00e4nderst. Teste, was passiert, wenn du den R\u00fcckgabewert ver\u00e4nderst \u2013 z. B. durch eine andere Nachricht oder eine Zahl.","title":"Aufgabe"},{"location":"fastapi/first_steps/#parameter-in-der-url","text":"Ein h\u00e4ufiges Szenario ist, dass wir Daten dynamisch basierend auf der Anfrage bereitstellen wollen. Nehmen wir an, wir m\u00f6chten eine Nachricht zur\u00fcckgeben, die den Namen des Benutzers enth\u00e4lt. Dazu f\u00fcgen wir einen URL-Parameter hinzu, der in die Route integriert wird. @app.get(\"/hello/{name}\") async def read_item(name: str): return {\"message\": f\"Hello, {name}!\"} Hier erstellen wir eine GET -Route mit einem dynamischen Segment {name} , das wir im Funktionsparameter name auffangen. Wenn wir http://127.0.0.1:8000/hello/Alex aufrufen, erhalten wir die Antwort: \u201eHello, Alex!\u201c","title":"Parameter in der URL"},{"location":"fastapi/first_steps/#aufgabe_1","text":"Erweitere die Route, um eine zweite Variable wie age oder city aufzunehmen. Erstelle eine Antwort, die beide Parameter in einem Begr\u00fc\u00dfungssatz verwendet. Teste verschiedene Namen und Werte, um zu sehen, wie FastAPI die Eingaben verarbeitet.","title":"Aufgabe"},{"location":"fastapi/first_steps/#verwendung-von-http-methoden-post","text":"Neben GET gibt es noch weitere HTTP-Methoden wie POST , PUT und DELETE , die alle unterschiedliche Zwecke erf\u00fcllen. POST -Anfragen werden typischerweise verwendet, um Daten an den Server zu senden, z. B. zum Erstellen eines neuen Eintrags. Angenommen, wir m\u00f6chten eine einfache Route erstellen, bei der der Benutzer eine Nachricht an den Server senden kann. Dabei nutzen wir die Methode POST , um die Nachricht vom Client entgegenzunehmen und eine Best\u00e4tigung zur\u00fcckzugeben. from pydantic import BaseModel class Message(BaseModel): content: str @app.post(\"/send-message/\") async def create_message(message: Message): return {\"received_message\": message.content} In diesem Beispiel erstellen wir ein Modell Message mit dem Attribut content , das eine Zeichenkette ist. Das @app.post(\"/send-message/\") zeigt FastAPI, dass dieser Endpunkt eine POST -Anfrage erwartet. Der Inhalt wird in Form eines JSON-Objekts vom Client gesendet und in das message -Objekt des Typs Message umgewandelt. Anschlie\u00dfend geben wir die empfangene Nachricht als Best\u00e4tigung zur\u00fcck.","title":"Verwendung von HTTP-Methoden: POST"},{"location":"fastapi/first_steps/#aufgabe_2","text":"Teste diese POST -Route mit einem API-Client wie Postman oder durch einen Browser-Extension. Sende eine JSON-Nachricht wie {\"content\": \"Dies ist meine erste Nachricht\"} . Experimentiere mit verschiedenen Nachrichten und \u00fcberpr\u00fcfe, wie FastAPI die Antwort generiert.","title":"Aufgabe"},{"location":"fastapi/first_steps/#arbeiten-mit-query-parametern","text":"Neben Routenparametern und POST -Daten bietet FastAPI die M\u00f6glichkeit, Query-Parameter zu verwenden. Diese Art von Parametern befindet sich in der URL nach einem ? und wird h\u00e4ufig f\u00fcr zus\u00e4tzliche, optionale Informationen genutzt. Beispielsweise m\u00f6chten wir eine Route erstellen, bei der der Benutzer seinen Namen als Query-Parameter senden kann, ohne ihn in der URL selbst zu definieren. @app.get(\"/greet/\") async def greet_user(name: str = \"Gast\"): return {\"message\": f\"Hallo, {name}!\"} In dieser Route verwenden wir den Query-Parameter name , der standardm\u00e4\u00dfig \u201eGast\u201c ist, falls kein Wert \u00fcbergeben wird. Wenn wir http://127.0.0.1:8000/greet/?name=Lisa aufrufen, erhalten wir die Antwort \u201eHallo, Lisa!\u201c.","title":"Arbeiten mit Query-Parametern"},{"location":"fastapi/first_steps/#aufgabe_3","text":"Experimentiere mit der URL und dem name -Parameter. Probiere verschiedene Namen und teste, was passiert, wenn du den Parameter wegl\u00e4sst. Erweitere das Beispiel, indem du weitere optionale Query-Parameter hinzuf\u00fcgst, etwa age oder city .","title":"Aufgabe"},{"location":"fastapi/intro/","text":"Einf\u00fchrung in FastAPI Was ist FastAPI? FastAPI ist ein Web-Framework zur Entwicklung von APIs mit Python. Es wurde f\u00fcr den Einsatz in produktionskritischen Anwendungen entwickelt und zeichnet sich durch eine hohe Performance und einfache Handhabung aus. Kernmerkmale von FastAPI Automatische Dokumentation : FastAPI generiert automatisch interaktive API-Dokumentationen (Swagger UI, Redoc) auf Basis des OpenAPI-Standards. Asynchrone Verarbeitung : Unterst\u00fctzung f\u00fcr async und await erleichtert das Handling von asynchronen Aufgaben und macht FastAPI ideal f\u00fcr Anwendungen mit hohen Anforderungen an die Skalierbarkeit. Einfache Validierung : FastAPI verwendet Pydantic zur Validierung und Serialisierung von Daten, wodurch die Datenintegrit\u00e4t automatisch gesichert wird. Beispiel einer FastAPI-Anwendung Hier eine grundlegende FastAPI-Anwendung, die einen \"Hello World\"-Endpunkt bereitstellt: from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def root(): return {\"message\": \"Hello, World!\"} Installation FastAPI kann \u00fcber pip installiert werden: pip install fastapi[all] Zus\u00e4tzlich wird ein ASGI-Server wie uvicorn ben\u00f6tigt, um die Anwendung zu starten: pip install uvicorn uvicorn main:app --reload FastAPI vs. Flask FastAPI und Flask sind beide beliebte Python-Frameworks zur API-Entwicklung, unterscheiden sich jedoch erheblich in ihrer Funktionsweise und ihrem Anwendungsbereich. Hauptunterschiede Merkmal Flask FastAPI Asynchronit\u00e4t Unterst\u00fctzung nur mit zus\u00e4tzlichen Bibliotheken wie flask-async Eingebaute Unterst\u00fctzung f\u00fcr async und await Performance Moderate Geschwindigkeit Hohe Performance durch asynchrone Architektur Datenvalidierung Keine eingebaute Validierung, zus\u00e4tzliche Bibliotheken wie marshmallow erforderlich Integrierte Validierung mit Pydantic Dokumentation Keine automatische Dokumentation Automatische Generierung von Swagger UI und Redoc Ideal f\u00fcr Einfache APIs und Anwendungen APIs mit hoher Leistung und komplexen Datenvalidierungsanforderungen Wann man FastAPI verwenden sollte Wenn hohe Performance und Skalierbarkeit gefordert sind. F\u00fcr APIs, die asynchrone Verarbeitung ben\u00f6tigen. Bei Projekten, in denen die automatische Dokumentation n\u00fctzlich ist. Wann Flask geeigneter ist Bei einfachen Anwendungen oder Prototypen, die nur grundlegende Funktionalit\u00e4ten ben\u00f6tigen. Wenn Asynchronit\u00e4t und Performance keine kritischen Anforderungen sind.","title":"Einf\u00fchrung in FastAPI"},{"location":"fastapi/intro/#einfuhrung-in-fastapi","text":"","title":"Einf\u00fchrung in FastAPI"},{"location":"fastapi/intro/#was-ist-fastapi","text":"FastAPI ist ein Web-Framework zur Entwicklung von APIs mit Python. Es wurde f\u00fcr den Einsatz in produktionskritischen Anwendungen entwickelt und zeichnet sich durch eine hohe Performance und einfache Handhabung aus.","title":"Was ist FastAPI?"},{"location":"fastapi/intro/#kernmerkmale-von-fastapi","text":"Automatische Dokumentation : FastAPI generiert automatisch interaktive API-Dokumentationen (Swagger UI, Redoc) auf Basis des OpenAPI-Standards. Asynchrone Verarbeitung : Unterst\u00fctzung f\u00fcr async und await erleichtert das Handling von asynchronen Aufgaben und macht FastAPI ideal f\u00fcr Anwendungen mit hohen Anforderungen an die Skalierbarkeit. Einfache Validierung : FastAPI verwendet Pydantic zur Validierung und Serialisierung von Daten, wodurch die Datenintegrit\u00e4t automatisch gesichert wird.","title":"Kernmerkmale von FastAPI"},{"location":"fastapi/intro/#beispiel-einer-fastapi-anwendung","text":"Hier eine grundlegende FastAPI-Anwendung, die einen \"Hello World\"-Endpunkt bereitstellt: from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def root(): return {\"message\": \"Hello, World!\"}","title":"Beispiel einer FastAPI-Anwendung"},{"location":"fastapi/intro/#installation","text":"FastAPI kann \u00fcber pip installiert werden: pip install fastapi[all] Zus\u00e4tzlich wird ein ASGI-Server wie uvicorn ben\u00f6tigt, um die Anwendung zu starten: pip install uvicorn uvicorn main:app --reload","title":"Installation"},{"location":"fastapi/intro/#fastapi-vs-flask","text":"FastAPI und Flask sind beide beliebte Python-Frameworks zur API-Entwicklung, unterscheiden sich jedoch erheblich in ihrer Funktionsweise und ihrem Anwendungsbereich.","title":"FastAPI vs. Flask"},{"location":"fastapi/intro/#hauptunterschiede","text":"Merkmal Flask FastAPI Asynchronit\u00e4t Unterst\u00fctzung nur mit zus\u00e4tzlichen Bibliotheken wie flask-async Eingebaute Unterst\u00fctzung f\u00fcr async und await Performance Moderate Geschwindigkeit Hohe Performance durch asynchrone Architektur Datenvalidierung Keine eingebaute Validierung, zus\u00e4tzliche Bibliotheken wie marshmallow erforderlich Integrierte Validierung mit Pydantic Dokumentation Keine automatische Dokumentation Automatische Generierung von Swagger UI und Redoc Ideal f\u00fcr Einfache APIs und Anwendungen APIs mit hoher Leistung und komplexen Datenvalidierungsanforderungen","title":"Hauptunterschiede"},{"location":"fastapi/intro/#wann-man-fastapi-verwenden-sollte","text":"Wenn hohe Performance und Skalierbarkeit gefordert sind. F\u00fcr APIs, die asynchrone Verarbeitung ben\u00f6tigen. Bei Projekten, in denen die automatische Dokumentation n\u00fctzlich ist.","title":"Wann man FastAPI verwenden sollte"},{"location":"fastapi/intro/#wann-flask-geeigneter-ist","text":"Bei einfachen Anwendungen oder Prototypen, die nur grundlegende Funktionalit\u00e4ten ben\u00f6tigen. Wenn Asynchronit\u00e4t und Performance keine kritischen Anforderungen sind.","title":"Wann Flask geeigneter ist"},{"location":"fastapi/sqlmodel/","text":"Arbeiten mit SQLModel in FastAPI SQLModel ist eine Bibliothek, die SQLAlchemy und Pydantic kombiniert. Sie erm\u00f6glicht es dir, Datenbankmodelle in FastAPI zu integrieren, ohne auf umfangreiche ORM-Definitionen verzichten zu m\u00fcssen. SQLModel baut auf SQLAlchemy auf und verwendet Pydantic zur Validierung der Daten, sodass du Datenbankmodelle erstellen und gleichzeitig die Vorteile der Datenvalidierung von Pydantic nutzen kannst. Was ist SQLModel? SQLModel ist eine Bibliothek, die es erm\u00f6glicht, SQL-Datenbanken in FastAPI-Anwendungen zu integrieren. Sie stellt eine einfache Schnittstelle zur Verf\u00fcgung, die es dir erm\u00f6glicht, sowohl Datenbankmodelle zu definieren als auch mit der Datenbank zu interagieren \u2013 alles in einer sauberen und einheitlichen API. SQLModel erm\u00f6glicht die Definition von Pydantic-Modellen , die gleichzeitig auch Datenbankmodelle sind. Das bedeutet, dass du nur ein Modell schreiben musst, um sowohl mit der Datenbank als auch mit FastAPI zu arbeiten. Installation pip install sqlmodel Erstellen eines einfachen SQLModel-Datenmodells Ein SQLModel-Datenmodell ist sehr \u00e4hnlich wie ein Pydantic-Modell, aber mit zus\u00e4tzlichen SQLAlchemy-Features wie Field und Relationship f\u00fcr die Datenbankinteraktion. from sqlmodel import Field, SQLModel class User(SQLModel, table=True): id: int = Field(default=None, primary_key=True) name: str email: str age: int In diesem Beispiel haben wir ein einfaches User-Modell erstellt, das die Felder id , name , email und age enth\u00e4lt. Das table=True -Attribut signalisiert, dass dieses Modell eine Tabelle in der Datenbank repr\u00e4sentiert. Aufgabe Erstelle ein weiteres Datenmodell, das Product -Daten mit den Feldern name , price und description speichert. Vergiss nicht, die id als Prim\u00e4rschl\u00fcssel hinzuzuf\u00fcgen. Datenbankverbindungen und Sessions Eine der wichtigsten Aufgaben beim Arbeiten mit SQLModel ist die Verbindung zur Datenbank und die Verwaltung von Sessions, um Transaktionen durchzuf\u00fchren. SQLModel baut auf SQLAlchemy auf, sodass wir die gleiche Methode verwenden, um die Verbindung zur Datenbank herzustellen. Verbindung zur Datenbank herstellen Du kannst SQLModel mit einer SQLite-Datenbank oder einer anderen unterst\u00fctzten Datenbank wie PostgreSQL oder MySQL verwenden. Hier ist ein einfaches Beispiel f\u00fcr die Verbindung zu einer SQLite-Datenbank: from sqlmodel import create_engine, Session # Erstelle die Verbindung zur SQLite-Datenbank engine = create_engine(\"sqlite:///database.db\") # Erstelle die Tabellen in der Datenbank (falls sie noch nicht existieren) SQLModel.metadata.create_all(engine) Arbeiten mit Sessions Um mit der Datenbank zu interagieren, musst du eine Session erstellen, die es dir erm\u00f6glicht, Datens\u00e4tze zu lesen, zu schreiben und zu aktualisieren. from sqlmodel import Session # \u00d6ffne eine Session, um mit der Datenbank zu interagieren with Session(engine) as session: # Beispiel: Hinzuf\u00fcgen eines neuen Benutzers user = User(name=\"John Doe\", email=\"johndoe@example.com\", age=30) session.add(user) session.commit() Aufgabe Erstelle eine neue Product -Instanz, f\u00fcge sie zur Datenbank hinzu und best\u00e4tige die Transaktion mit session.commit() . CRUD-Operationen mit SQLModel SQLModel macht es einfach, grundlegende CRUD -Operationen (Create, Read, Update, Delete) auf Datenbanken durchzuf\u00fchren. Nachdem du die Datenbankverbindung und das Modell eingerichtet hast, kannst du Datens\u00e4tze einfach erstellen und abfragen. Erstellen eines Datensatzes (Create) with Session(engine) as session: new_user = User(name=\"Jane Doe\", email=\"janedoe@example.com\", age=25) session.add(new_user) session.commit() Lesen von Datens\u00e4tzen (Read) with Session(engine) as session: user = session.query(User).filter(User.name == \"Jane Doe\").first() print(user) Aktualisieren von Datens\u00e4tzen (Update) with Session(engine) as session: user = session.query(User).filter(User.name == \"Jane Doe\").first() if user: user.age = 26 session.commit() L\u00f6schen von Datens\u00e4tzen (Delete) with Session(engine) as session: user = session.query(User).filter(User.name == \"Jane Doe\").first() if user: session.delete(user) session.commit() Aufgabe Erweitere das User -Modell um ein address -Feld und f\u00fchre eine UPDATE -Operation durch, um die Adresse eines bestimmten Benutzers zu \u00e4ndern. Integration von SQLModel mit FastAPI Ein gro\u00dfer Vorteil von SQLModel ist, dass es nahtlos mit FastAPI integriert werden kann. Du kannst SQLModel-Modelle direkt in deine FastAPI-Routen einbinden, um API-Endpunkte zu erstellen, die mit der Datenbank interagieren. Beispiel f\u00fcr einen FastAPI-Endpunkt mit SQLModel from fastapi import FastAPI from sqlmodel import Session, select app = FastAPI() @app.post(\"/users/\") async def create_user(user: User): with Session(engine) as session: session.add(user) session.commit() return {\"user\": user} In diesem Beispiel haben wir eine POST -Route erstellt, die ein User -Objekt entgegennimmt und es in die Datenbank speichert. Aufgabe Erstelle eine GET -Route, die alle Benutzer aus der Datenbank abruft und zur\u00fcckgibt.","title":"Arbeiten mit SQLModel in FastAPI"},{"location":"fastapi/sqlmodel/#arbeiten-mit-sqlmodel-in-fastapi","text":"SQLModel ist eine Bibliothek, die SQLAlchemy und Pydantic kombiniert. Sie erm\u00f6glicht es dir, Datenbankmodelle in FastAPI zu integrieren, ohne auf umfangreiche ORM-Definitionen verzichten zu m\u00fcssen. SQLModel baut auf SQLAlchemy auf und verwendet Pydantic zur Validierung der Daten, sodass du Datenbankmodelle erstellen und gleichzeitig die Vorteile der Datenvalidierung von Pydantic nutzen kannst.","title":"Arbeiten mit SQLModel in FastAPI"},{"location":"fastapi/sqlmodel/#was-ist-sqlmodel","text":"SQLModel ist eine Bibliothek, die es erm\u00f6glicht, SQL-Datenbanken in FastAPI-Anwendungen zu integrieren. Sie stellt eine einfache Schnittstelle zur Verf\u00fcgung, die es dir erm\u00f6glicht, sowohl Datenbankmodelle zu definieren als auch mit der Datenbank zu interagieren \u2013 alles in einer sauberen und einheitlichen API. SQLModel erm\u00f6glicht die Definition von Pydantic-Modellen , die gleichzeitig auch Datenbankmodelle sind. Das bedeutet, dass du nur ein Modell schreiben musst, um sowohl mit der Datenbank als auch mit FastAPI zu arbeiten.","title":"Was ist SQLModel?"},{"location":"fastapi/sqlmodel/#installation","text":"pip install sqlmodel","title":"Installation"},{"location":"fastapi/sqlmodel/#erstellen-eines-einfachen-sqlmodel-datenmodells","text":"Ein SQLModel-Datenmodell ist sehr \u00e4hnlich wie ein Pydantic-Modell, aber mit zus\u00e4tzlichen SQLAlchemy-Features wie Field und Relationship f\u00fcr die Datenbankinteraktion. from sqlmodel import Field, SQLModel class User(SQLModel, table=True): id: int = Field(default=None, primary_key=True) name: str email: str age: int In diesem Beispiel haben wir ein einfaches User-Modell erstellt, das die Felder id , name , email und age enth\u00e4lt. Das table=True -Attribut signalisiert, dass dieses Modell eine Tabelle in der Datenbank repr\u00e4sentiert.","title":"Erstellen eines einfachen SQLModel-Datenmodells"},{"location":"fastapi/sqlmodel/#aufgabe","text":"Erstelle ein weiteres Datenmodell, das Product -Daten mit den Feldern name , price und description speichert. Vergiss nicht, die id als Prim\u00e4rschl\u00fcssel hinzuzuf\u00fcgen.","title":"Aufgabe"},{"location":"fastapi/sqlmodel/#datenbankverbindungen-und-sessions","text":"Eine der wichtigsten Aufgaben beim Arbeiten mit SQLModel ist die Verbindung zur Datenbank und die Verwaltung von Sessions, um Transaktionen durchzuf\u00fchren. SQLModel baut auf SQLAlchemy auf, sodass wir die gleiche Methode verwenden, um die Verbindung zur Datenbank herzustellen.","title":"Datenbankverbindungen und Sessions"},{"location":"fastapi/sqlmodel/#verbindung-zur-datenbank-herstellen","text":"Du kannst SQLModel mit einer SQLite-Datenbank oder einer anderen unterst\u00fctzten Datenbank wie PostgreSQL oder MySQL verwenden. Hier ist ein einfaches Beispiel f\u00fcr die Verbindung zu einer SQLite-Datenbank: from sqlmodel import create_engine, Session # Erstelle die Verbindung zur SQLite-Datenbank engine = create_engine(\"sqlite:///database.db\") # Erstelle die Tabellen in der Datenbank (falls sie noch nicht existieren) SQLModel.metadata.create_all(engine)","title":"Verbindung zur Datenbank herstellen"},{"location":"fastapi/sqlmodel/#arbeiten-mit-sessions","text":"Um mit der Datenbank zu interagieren, musst du eine Session erstellen, die es dir erm\u00f6glicht, Datens\u00e4tze zu lesen, zu schreiben und zu aktualisieren. from sqlmodel import Session # \u00d6ffne eine Session, um mit der Datenbank zu interagieren with Session(engine) as session: # Beispiel: Hinzuf\u00fcgen eines neuen Benutzers user = User(name=\"John Doe\", email=\"johndoe@example.com\", age=30) session.add(user) session.commit()","title":"Arbeiten mit Sessions"},{"location":"fastapi/sqlmodel/#aufgabe_1","text":"Erstelle eine neue Product -Instanz, f\u00fcge sie zur Datenbank hinzu und best\u00e4tige die Transaktion mit session.commit() .","title":"Aufgabe"},{"location":"fastapi/sqlmodel/#crud-operationen-mit-sqlmodel","text":"SQLModel macht es einfach, grundlegende CRUD -Operationen (Create, Read, Update, Delete) auf Datenbanken durchzuf\u00fchren. Nachdem du die Datenbankverbindung und das Modell eingerichtet hast, kannst du Datens\u00e4tze einfach erstellen und abfragen.","title":"CRUD-Operationen mit SQLModel"},{"location":"fastapi/sqlmodel/#erstellen-eines-datensatzes-create","text":"with Session(engine) as session: new_user = User(name=\"Jane Doe\", email=\"janedoe@example.com\", age=25) session.add(new_user) session.commit()","title":"Erstellen eines Datensatzes (Create)"},{"location":"fastapi/sqlmodel/#lesen-von-datensatzen-read","text":"with Session(engine) as session: user = session.query(User).filter(User.name == \"Jane Doe\").first() print(user)","title":"Lesen von Datens\u00e4tzen (Read)"},{"location":"fastapi/sqlmodel/#aktualisieren-von-datensatzen-update","text":"with Session(engine) as session: user = session.query(User).filter(User.name == \"Jane Doe\").first() if user: user.age = 26 session.commit()","title":"Aktualisieren von Datens\u00e4tzen (Update)"},{"location":"fastapi/sqlmodel/#loschen-von-datensatzen-delete","text":"with Session(engine) as session: user = session.query(User).filter(User.name == \"Jane Doe\").first() if user: session.delete(user) session.commit()","title":"L\u00f6schen von Datens\u00e4tzen (Delete)"},{"location":"fastapi/sqlmodel/#aufgabe_2","text":"Erweitere das User -Modell um ein address -Feld und f\u00fchre eine UPDATE -Operation durch, um die Adresse eines bestimmten Benutzers zu \u00e4ndern.","title":"Aufgabe"},{"location":"fastapi/sqlmodel/#integration-von-sqlmodel-mit-fastapi","text":"Ein gro\u00dfer Vorteil von SQLModel ist, dass es nahtlos mit FastAPI integriert werden kann. Du kannst SQLModel-Modelle direkt in deine FastAPI-Routen einbinden, um API-Endpunkte zu erstellen, die mit der Datenbank interagieren.","title":"Integration von SQLModel mit FastAPI"},{"location":"fastapi/sqlmodel/#beispiel-fur-einen-fastapi-endpunkt-mit-sqlmodel","text":"from fastapi import FastAPI from sqlmodel import Session, select app = FastAPI() @app.post(\"/users/\") async def create_user(user: User): with Session(engine) as session: session.add(user) session.commit() return {\"user\": user} In diesem Beispiel haben wir eine POST -Route erstellt, die ein User -Objekt entgegennimmt und es in die Datenbank speichert.","title":"Beispiel f\u00fcr einen FastAPI-Endpunkt mit SQLModel"},{"location":"fastapi/sqlmodel/#aufgabe_3","text":"Erstelle eine GET -Route, die alle Benutzer aus der Datenbank abruft und zur\u00fcckgibt.","title":"Aufgabe"},{"location":"fastapi/task/","text":"Vorhersage des Einkommens basierend auf dem Adult Income Dataset In dieser Aufgabe wirst du das Adult Income Dataset verwenden, um ein einfaches API-Modell zu erstellen, das die Wahrscheinlichkeit vorhersagt, ob jemand mehr als 50.000 USD j\u00e4hrlich verdient, basierend auf verschiedenen demografischen Merkmalen. Du wirst SQLModel f\u00fcr das Speichern der Daten in einer Datenbank und FastAPI f\u00fcr die API-Erstellung verwenden. Aufgabe 1: Datenvorbereitung und -verst\u00e4ndnis Lade das Adult Income Dataset herunter und analysiere die Spalten. Erstelle ein Streamlit Dashboard oder Jupyter Notebook, um den Datensatz visuell aufzubereiten. Der Datensatz enth\u00e4lt folgende Merkmale: age : Alter der Person workclass : Arbeitsverh\u00e4ltnis (z.B. privat, \u00f6ffentlich) fnlwgt : Gewicht (repr\u00e4sentiert die Anzahl der Menschen, die in der Stichprobe repr\u00e4sentiert sind) education : H\u00f6chster Bildungsabschluss education-num : Bildung in numerischer Form marital-status : Familienstand occupation : Beruf relationship : Beziehung zum Haushaltsvorstand race : Rasse sex : Geschlecht capital-gain : Kapitalgewinne capital-loss : Kapitalverlust hours-per-week : Arbeitsstunden pro Woche native-country : Geburtsland income : Einkommen (mehr als 50K oder weniger) Aufgabe 2: Erstellen eines SQLModel-Datenmodells Erstelle ein User -Datenmodell mit SQLModel, das die oben genannten Merkmale repr\u00e4sentiert. Definiere auch den Typ der Merkmale (z. B. age als Integer, education als String). Aufgabe 3: API-Erstellung mit FastAPI Erstelle eine FastAPI-Anwendung, die folgende Funktionalit\u00e4ten bietet: Daten hinzuf\u00fcgen : Erstelle eine POST-Route, die es erm\u00f6glicht, neue Benutzerdaten hinzuzuf\u00fcgen. Die Route sollte alle Merkmale des Datensatzes akzeptieren. Daten abfragen : Erstelle eine GET-Route, um alle gespeicherten Benutzerdaten abzurufen. Einkommensvorhersage : Erstelle eine weitere POST-Route, die basierend auf den eingegebenen demografischen Merkmalen vorhersagt, ob das Einkommen mehr als 50.000 USD betr\u00e4gt oder nicht. Diese Route sollte ein Modell wie z. B. einen einfachen Entscheidungsbaum verwenden (der zuvor auf den Daten trainiert wurde), um die Vorhersage zu treffen. Aufgabe 4: Testen der API mit Postman oder einem anderen API-Client Daten hinzuf\u00fcgen : Verwende die POST-Route /add-user (oder eine benannte Route) zum Hinzuf\u00fcgen eines neuen Datensatzes. Daten abfragen : Verwende die GET-Route /users , um alle gespeicherten Benutzer abzurufen. Einkommensvorhersage : Teste die /predict-income/ -Route, indem du verschiedene Werte f\u00fcr age , hours-per-week und andere Merkmale eingibst. Aufgabe 5 (Zusatz): Analyse und Modellverbesserung Nachdem du die API erstellt hast, analysiere die Vorhersageergebnisse und \u00fcberlege, wie du das Modell verbessern kannst","title":"Vorhersage des Einkommens basierend auf dem Adult Income Dataset"},{"location":"fastapi/task/#vorhersage-des-einkommens-basierend-auf-dem-adult-income-dataset","text":"In dieser Aufgabe wirst du das Adult Income Dataset verwenden, um ein einfaches API-Modell zu erstellen, das die Wahrscheinlichkeit vorhersagt, ob jemand mehr als 50.000 USD j\u00e4hrlich verdient, basierend auf verschiedenen demografischen Merkmalen. Du wirst SQLModel f\u00fcr das Speichern der Daten in einer Datenbank und FastAPI f\u00fcr die API-Erstellung verwenden.","title":"Vorhersage des Einkommens basierend auf dem Adult Income Dataset"},{"location":"fastapi/task/#aufgabe-1-datenvorbereitung-und-verstandnis","text":"Lade das Adult Income Dataset herunter und analysiere die Spalten. Erstelle ein Streamlit Dashboard oder Jupyter Notebook, um den Datensatz visuell aufzubereiten. Der Datensatz enth\u00e4lt folgende Merkmale: age : Alter der Person workclass : Arbeitsverh\u00e4ltnis (z.B. privat, \u00f6ffentlich) fnlwgt : Gewicht (repr\u00e4sentiert die Anzahl der Menschen, die in der Stichprobe repr\u00e4sentiert sind) education : H\u00f6chster Bildungsabschluss education-num : Bildung in numerischer Form marital-status : Familienstand occupation : Beruf relationship : Beziehung zum Haushaltsvorstand race : Rasse sex : Geschlecht capital-gain : Kapitalgewinne capital-loss : Kapitalverlust hours-per-week : Arbeitsstunden pro Woche native-country : Geburtsland income : Einkommen (mehr als 50K oder weniger)","title":"Aufgabe 1: Datenvorbereitung und -verst\u00e4ndnis"},{"location":"fastapi/task/#aufgabe-2-erstellen-eines-sqlmodel-datenmodells","text":"Erstelle ein User -Datenmodell mit SQLModel, das die oben genannten Merkmale repr\u00e4sentiert. Definiere auch den Typ der Merkmale (z. B. age als Integer, education als String).","title":"Aufgabe 2: Erstellen eines SQLModel-Datenmodells"},{"location":"fastapi/task/#aufgabe-3-api-erstellung-mit-fastapi","text":"Erstelle eine FastAPI-Anwendung, die folgende Funktionalit\u00e4ten bietet: Daten hinzuf\u00fcgen : Erstelle eine POST-Route, die es erm\u00f6glicht, neue Benutzerdaten hinzuzuf\u00fcgen. Die Route sollte alle Merkmale des Datensatzes akzeptieren. Daten abfragen : Erstelle eine GET-Route, um alle gespeicherten Benutzerdaten abzurufen. Einkommensvorhersage : Erstelle eine weitere POST-Route, die basierend auf den eingegebenen demografischen Merkmalen vorhersagt, ob das Einkommen mehr als 50.000 USD betr\u00e4gt oder nicht. Diese Route sollte ein Modell wie z. B. einen einfachen Entscheidungsbaum verwenden (der zuvor auf den Daten trainiert wurde), um die Vorhersage zu treffen.","title":"Aufgabe 3: API-Erstellung mit FastAPI"},{"location":"fastapi/task/#aufgabe-4-testen-der-api-mit-postman-oder-einem-anderen-api-client","text":"Daten hinzuf\u00fcgen : Verwende die POST-Route /add-user (oder eine benannte Route) zum Hinzuf\u00fcgen eines neuen Datensatzes. Daten abfragen : Verwende die GET-Route /users , um alle gespeicherten Benutzer abzurufen. Einkommensvorhersage : Teste die /predict-income/ -Route, indem du verschiedene Werte f\u00fcr age , hours-per-week und andere Merkmale eingibst.","title":"Aufgabe 4: Testen der API mit Postman oder einem anderen API-Client"},{"location":"fastapi/task/#aufgabe-5-zusatz-analyse-und-modellverbesserung","text":"Nachdem du die API erstellt hast, analysiere die Vorhersageergebnisse und \u00fcberlege, wie du das Modell verbessern kannst","title":"Aufgabe 5 (Zusatz): Analyse und Modellverbesserung"}]}