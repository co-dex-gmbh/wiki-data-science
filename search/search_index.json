{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kurs\u00fcbersicht","text":""},{"location":"#kursinhalte","title":"Kursinhalte:","text":"Thema Beschreibung FastAPI Einf\u00fchrung in FastAPI: Erstellung von APIs und Routen. Pydantic Datenvalidierung und Modellierung mit Pydantic. SQLModel Integration von SQLModel f\u00fcr den Umgang mit Datenbanken in FastAPI."},{"location":"#projekte","title":"Projekte:","text":"<p>Hier ist Platz f\u00fcr gemeinsame Projekte, welche in diesem Kurs bearbeitet werden:</p>"},{"location":"fastapi/data_models/","title":"Datenmodelle mit Pydantic in FastAPI","text":"<p>Datenmodelle sind ein wesentlicher Bestandteil von APIs, da sie definieren, welche Art von Daten zwischen dem Server und den Clients ausgetauscht werden kann. In FastAPI \u00fcbernimmt die Bibliothek Pydantic diese Aufgabe, indem sie Python-Datenstrukturen in valide JSON-Objekte verwandelt. Pydantic bietet starke Validierungs- und Typisierungsfunktionen und erm\u00f6glicht es uns, Daten mit minimalem Aufwand zu strukturieren und zu validieren.</p>"},{"location":"fastapi/data_models/#warum-pydantic","title":"Warum Pydantic?","text":"<p>Pydantic ist eine zentrale Bibliothek in FastAPI, da sie eine einfache M\u00f6glichkeit bietet, Daten zu validieren und zu serialisieren. Mit Pydantic k\u00f6nnen wir sicherstellen, dass die Daten, die von einem Client gesendet werden oder an diesen zur\u00fcckgegeben werden, den gew\u00fcnschten Typen entsprechen. Dies verringert potenzielle Fehler und macht den Code robuster und lesbarer.</p>"},{"location":"fastapi/data_models/#typisierung-und-validierung","title":"Typisierung und Validierung","text":"<p>Pydantic nutzt Python\u2019s Typannotation, um die Struktur der Daten zu definieren und die Validierung basierend auf den angegebenen Datentypen durchzuf\u00fchren. Wenn du also ein Modell mit Feldern wie <code>str</code>, <code>int</code> oder <code>EmailStr</code> erstellst, stellt Pydantic sicher, dass die Daten den entsprechenden Typen entsprechen.</p> <p>Ein Beispiel f\u00fcr eine einfache Typisierung:</p> <pre><code>from pydantic import BaseModel, EmailStr\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n    age: int\n</code></pre> <p>Hier sorgt Pydantic daf\u00fcr, dass die <code>email</code>-Adresse als g\u00fcltige E-Mail-Adresse formatiert ist, w\u00e4hrend der Name ein String und das Alter eine Ganzzahl ist.</p>"},{"location":"fastapi/data_models/#unterstutzte-datentypen","title":"Unterst\u00fctzte Datentypen","text":"<p>Pydantic unterst\u00fctzt eine breite Palette von Datentypen, um unterschiedliche Anwendungsf\u00e4lle abzudecken. Zu den wichtigsten geh\u00f6ren:</p> <ul> <li>Primitive Typen: <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code></li> <li>Spezielle Typen: <code>EmailStr</code>, <code>UUID</code>, <code>IPv4</code>, <code>IPv6</code></li> <li>Optionale Felder: <code>Optional[T]</code>, um Felder als optional zu kennzeichnen</li> <li>Listen und Tupel: <code>List[T]</code>, <code>Tuple[T, ...]</code></li> <li>Datum und Uhrzeit: <code>datetime</code>, <code>date</code>, <code>time</code></li> </ul>"},{"location":"fastapi/data_models/#erstellen-eines-einfachen-datenmodells","title":"Erstellen eines einfachen Datenmodells","text":"<p>Schauen wir uns ein einfaches Beispiel an: Wir m\u00f6chten eine API, die Benutzerdaten wie <code>name</code>, <code>email</code> und <code>age</code> verarbeitet. Mit Pydantic definieren wir die Struktur der zu verarbeitenden Daten.</p> <pre><code>from pydantic import BaseModel, EmailStr\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n    age: int\n</code></pre> <p>In diesem Modell wird <code>name</code> als <code>str</code>, <code>email</code> als <code>EmailStr</code> und <code>age</code> als <code>int</code> validiert. Die <code>EmailStr</code>-Typisierung stellt sicher, dass die Eingabe eine g\u00fcltige E-Mail-Adresse ist.</p>"},{"location":"fastapi/data_models/#aufgabe","title":"Aufgabe","text":"<p>Erweitere das <code>User</code>-Modell, indem du ein optionales Feld f\u00fcr <code>city</code> hinzuf\u00fcgst, das einen Standardwert hat, zum Beispiel <code>\"Unbekannt\"</code>. F\u00fcge au\u00dferdem ein Feld <code>is_active</code> hinzu, das einen <code>bool</code>-Wert erwartet und standardm\u00e4\u00dfig auf <code>True</code> gesetzt ist.</p>"},{"location":"fastapi/data_models/#modell-in-fastapi-einbinden","title":"Modell in FastAPI einbinden","text":"<p>Nachdem wir das Datenmodell mit Pydantic erstellt haben, wollen wir es in einer FastAPI-Anwendung verwenden. FastAPI erm\u00f6glicht es uns, Pydantic-Modelle direkt in Routen zu integrieren. So k\u00f6nnen wir sicherstellen, dass alle eingehenden Daten den definierten Anforderungen entsprechen.</p> <pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\nfrom typing import Optional\n\napp = FastAPI()\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n    age: int\n    city: Optional[str] = \"Unbekannt\"\n    is_active: bool = True\n\n@app.post(\"/users/\")\nasync def create_user(user: User):\n    return {\"user\": user}\n</code></pre> <p>In diesem Beispiel haben wir die Route <code>/users/</code> erstellt, die einen <code>POST</code>-Request erwartet. FastAPI \u00fcbernimmt die Validierung der Daten und gibt die g\u00fcltigen Daten als Antwort zur\u00fcck.</p>"},{"location":"fastapi/data_models/#aufgabe_1","title":"Aufgabe","text":"<p>Teste die <code>/users/</code>-Route mit einem API-Client wie Postman. Sende ein JSON-Objekt, das die Felder <code>name</code>, <code>email</code> und <code>age</code> enth\u00e4lt, und \u00fcberpr\u00fcfe, wie FastAPI das Modell validiert und zur\u00fcckgibt.</p>"},{"location":"fastapi/data_models/#validierung-und-fehlerbehandlung","title":"Validierung und Fehlerbehandlung","text":"<p>FastAPI und Pydantic bieten umfangreiche M\u00f6glichkeiten, Daten zu validieren. Wenn Daten nicht den Anforderungen entsprechen, gibt FastAPI eine detaillierte Fehlermeldung zur\u00fcck, die den Entwickler genau dar\u00fcber informiert, welcher Wert nicht g\u00fcltig ist.</p>"},{"location":"fastapi/data_models/#beispiel-fur-eine-validierung","title":"Beispiel f\u00fcr eine Validierung:","text":"<pre><code>from pydantic import BaseModel, Field\n\nclass User(BaseModel):\n    name: str = Field(..., min_length=2, max_length=50)\n    email: EmailStr\n    age: int = Field(..., gt=0, le=120)  # Altersbeschr\u00e4nkung\n    city: Optional[str] = \"Unbekannt\"\n    is_active: bool = True\n</code></pre> <p>In diesem Beispiel haben wir Einschr\u00e4nkungen f\u00fcr das Feld <code>name</code> (minimale und maximale L\u00e4nge) und <code>age</code> (gr\u00f6\u00dfer als 0 und maximal 120 Jahre) definiert.</p> <p>Wenn jemand beispielsweise eine ung\u00fcltige E-Mail-Adresse sendet oder das Alter zu hoch ist, gibt FastAPI eine Fehlerantwort zur\u00fcck.</p>"},{"location":"fastapi/data_models/#aufgabe_2","title":"Aufgabe","text":"<p>Teste das Modell in einer einfachen <code>POST</code>-Route, indem du es in FastAPI integrierst. \u00dcbermittle verschiedene <code>name</code>- und <code>age</code>-Werte und beobachte die Fehlermeldungen, die FastAPI automatisch generiert, wenn die Validierungen fehlschlagen.</p>"},{"location":"fastapi/data_models/#eigene-validierungen","title":"Eigene Validierungen","text":"<p>Pydantic erm\u00f6glicht es, benutzerdefinierte Validierungen hinzuzuf\u00fcgen. Wenn du komplexere Anforderungen hast, die \u00fcber die Standardvalidierung hinausgehen, kannst du eigene Validierungsfunktionen implementieren.</p> <p>Ein Beispiel f\u00fcr eine benutzerdefinierte Validierung:</p> <pre><code>from pydantic import validator\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n    age: int\n\n    @validator(\"name\")\n    def name_must_not_contain_numbers(cls, v):\n        if any(char.isdigit() for char in v):\n            raise ValueError(\"Name darf keine Zahlen enthalten\")\n        return v\n</code></pre> <p>In diesem Beispiel wird eine Validierung f\u00fcr das Feld <code>name</code> hinzugef\u00fcgt, die sicherstellt, dass der Name keine Zahlen enth\u00e4lt.</p>"},{"location":"fastapi/data_models/#aufgabe_3","title":"Aufgabe","text":"<p>Erweitere den <code>name</code>-Validator, sodass er auch sicherstellt, dass der Name keine Sonderzeichen enth\u00e4lt. Teste den Validator, indem du Namen wie \u201eJohn@Doe\u201c und \u201e123Peter\u201c eingibst und \u00fcberpr\u00fcfe die Fehlermeldungen.</p>"},{"location":"fastapi/first_steps/","title":"Erste Schritte mit FastAPI: HTTP-Routen","text":"<p>In diesem Abschnitt sehen wir uns die Grundlagen von HTTP-Routen und die Erstellung von API-Endpunkte in fastapi an. HTTP-Routen sind das Herzst\u00fcck jeder API. Sie definieren die verschiedenen Wege, auf denen Clients (wie Webbrowser oder mobile Apps) mit unserem Server kommunizieren k\u00f6nnen. FastAPI macht es besonders einfach, diese Routen zu erstellen und f\u00fcr verschiedene Anfragen zu konfigurieren.</p>"},{"location":"fastapi/first_steps/#unsere-erste-route-get","title":"Unsere erste Route: <code>GET</code>","text":"<p>Beginnen wir noch einmal mit einer grundlegenden Route, die eine Nachricht an den Client zur\u00fcckgibt. Der <code>GET</code>-Anfragetyp ist der einfachste und am h\u00e4ufigsten verwendete HTTP-Methodentyp \u2013 er ruft einfach Daten ab, ohne dass eine \u00c4nderung am Server oder in der Datenbank vorgenommen wird.</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def read_root():\n    return {\"message\": \"Hello, World!\"}\n</code></pre> <p>In diesem Beispiel erstellen wir eine FastAPI-Instanz namens <code>app</code>. Dann definieren wir eine <code>GET</code>-Route mit dem Endpunkt <code>/</code>, die einfach \u201eHello, World!\u201c zur\u00fcckgibt. Der <code>@app.get(\"/\")</code>-Dekorator sagt FastAPI, dass dieser Endpunkt auf <code>GET</code>-Anfragen wartet.</p>"},{"location":"fastapi/first_steps/#aufgabe","title":"Aufgabe","text":"<p>Starte den Server und rufe <code>http://127.0.0.1:8000/</code> in deinem Browser oder einem API-Client wie Postman auf. Siehst du die Nachricht? Experimentiere, indem du den Text \u00e4nderst. Teste, was passiert, wenn du den R\u00fcckgabewert ver\u00e4nderst \u2013 z. B. durch eine andere Nachricht oder eine Zahl.</p>"},{"location":"fastapi/first_steps/#parameter-in-der-url","title":"Parameter in der URL","text":"<p>Ein h\u00e4ufiges Szenario ist, dass wir Daten dynamisch basierend auf der Anfrage bereitstellen wollen. Nehmen wir an, wir m\u00f6chten eine Nachricht zur\u00fcckgeben, die den Namen des Benutzers enth\u00e4lt. Dazu f\u00fcgen wir einen URL-Parameter hinzu, der in die Route integriert wird.</p> <pre><code>@app.get(\"/hello/{name}\")\nasync def read_item(name: str):\n    return {\"message\": f\"Hello, {name}!\"}\n</code></pre> <p>Hier erstellen wir eine <code>GET</code>-Route mit einem dynamischen Segment <code>{name}</code>, das wir im Funktionsparameter <code>name</code> auffangen. Wenn wir <code>http://127.0.0.1:8000/hello/Alex</code> aufrufen, erhalten wir die Antwort: \u201eHello, Alex!\u201c</p>"},{"location":"fastapi/first_steps/#aufgabe_1","title":"Aufgabe","text":"<p>Erweitere die Route, um eine zweite Variable wie <code>age</code> oder <code>city</code> aufzunehmen. Erstelle eine Antwort, die beide Parameter in einem Begr\u00fc\u00dfungssatz verwendet. Teste verschiedene Namen und Werte, um zu sehen, wie FastAPI die Eingaben verarbeitet.</p>"},{"location":"fastapi/first_steps/#verwendung-von-http-methoden-post","title":"Verwendung von HTTP-Methoden: <code>POST</code>","text":"<p>Neben <code>GET</code> gibt es noch weitere HTTP-Methoden wie <code>POST</code>, <code>PUT</code> und <code>DELETE</code>, die alle unterschiedliche Zwecke erf\u00fcllen. <code>POST</code>-Anfragen werden typischerweise verwendet, um Daten an den Server zu senden, z. B. zum Erstellen eines neuen Eintrags.</p> <p>Angenommen, wir m\u00f6chten eine einfache Route erstellen, bei der der Benutzer eine Nachricht an den Server senden kann. Dabei nutzen wir die Methode <code>POST</code>, um die Nachricht vom Client entgegenzunehmen und eine Best\u00e4tigung zur\u00fcckzugeben.</p> <pre><code>from pydantic import BaseModel\n\nclass Message(BaseModel):\n    content: str\n\n@app.post(\"/send-message/\")\nasync def create_message(message: Message):\n    return {\"received_message\": message.content}\n</code></pre> <p>In diesem Beispiel erstellen wir ein Modell <code>Message</code> mit dem Attribut <code>content</code>, das eine Zeichenkette ist. Das <code>@app.post(\"/send-message/\")</code> zeigt FastAPI, dass dieser Endpunkt eine <code>POST</code>-Anfrage erwartet. Der Inhalt wird in Form eines JSON-Objekts vom Client gesendet und in das <code>message</code>-Objekt des Typs <code>Message</code> umgewandelt. Anschlie\u00dfend geben wir die empfangene Nachricht als Best\u00e4tigung zur\u00fcck.</p>"},{"location":"fastapi/first_steps/#aufgabe_2","title":"Aufgabe","text":"<p>Teste diese <code>POST</code>-Route mit einem API-Client wie Postman oder durch einen Browser-Extension. Sende eine JSON-Nachricht wie <code>{\"content\": \"Dies ist meine erste Nachricht\"}</code>. Experimentiere mit verschiedenen Nachrichten und \u00fcberpr\u00fcfe, wie FastAPI die Antwort generiert.</p>"},{"location":"fastapi/first_steps/#arbeiten-mit-query-parametern","title":"Arbeiten mit Query-Parametern","text":"<p>Neben Routenparametern und <code>POST</code>-Daten bietet FastAPI die M\u00f6glichkeit, Query-Parameter zu verwenden. Diese Art von Parametern befindet sich in der URL nach einem <code>?</code> und wird h\u00e4ufig f\u00fcr zus\u00e4tzliche, optionale Informationen genutzt. Beispielsweise m\u00f6chten wir eine Route erstellen, bei der der Benutzer seinen Namen als Query-Parameter senden kann, ohne ihn in der URL selbst zu definieren.</p> <pre><code>@app.get(\"/greet/\")\nasync def greet_user(name: str = \"Gast\"):\n    return {\"message\": f\"Hallo, {name}!\"}\n</code></pre> <p>In dieser Route verwenden wir den Query-Parameter <code>name</code>, der standardm\u00e4\u00dfig \u201eGast\u201c ist, falls kein Wert \u00fcbergeben wird. Wenn wir <code>http://127.0.0.1:8000/greet/?name=Lisa</code> aufrufen, erhalten wir die Antwort \u201eHallo, Lisa!\u201c.</p>"},{"location":"fastapi/first_steps/#aufgabe_3","title":"Aufgabe","text":"<p>Experimentiere mit der URL und dem <code>name</code>-Parameter. Probiere verschiedene Namen und teste, was passiert, wenn du den Parameter wegl\u00e4sst. Erweitere das Beispiel, indem du weitere optionale Query-Parameter hinzuf\u00fcgst, etwa <code>age</code> oder <code>city</code>.</p>"},{"location":"fastapi/intro/","title":"Einf\u00fchrung in FastAPI","text":""},{"location":"fastapi/intro/#was-ist-fastapi","title":"Was ist FastAPI?","text":"<p>FastAPI ist ein Web-Framework zur Entwicklung von APIs mit Python. Es wurde f\u00fcr den Einsatz in produktionskritischen Anwendungen entwickelt und zeichnet sich durch eine hohe Performance und einfache Handhabung aus.</p>"},{"location":"fastapi/intro/#kernmerkmale-von-fastapi","title":"Kernmerkmale von FastAPI","text":"<ul> <li>Automatische Dokumentation: FastAPI generiert automatisch interaktive API-Dokumentationen (Swagger UI, Redoc) auf Basis des OpenAPI-Standards.</li> <li>Asynchrone Verarbeitung: Unterst\u00fctzung f\u00fcr <code>async</code> und <code>await</code> erleichtert das Handling von asynchronen Aufgaben und macht FastAPI ideal f\u00fcr Anwendungen mit hohen Anforderungen an die Skalierbarkeit.</li> <li>Einfache Validierung: FastAPI verwendet Pydantic zur Validierung und Serialisierung von Daten, wodurch die Datenintegrit\u00e4t automatisch gesichert wird.</li> </ul>"},{"location":"fastapi/intro/#beispiel-einer-fastapi-anwendung","title":"Beispiel einer FastAPI-Anwendung","text":"<p>Hier eine grundlegende FastAPI-Anwendung, die einen \"Hello World\"-Endpunkt bereitstellt:</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello, World!\"}\n</code></pre>"},{"location":"fastapi/intro/#installation","title":"Installation","text":"<p>FastAPI kann \u00fcber <code>pip</code> installiert werden:</p> <pre><code>pip install fastapi[all]\n</code></pre> <p>Zus\u00e4tzlich wird ein ASGI-Server wie uvicorn ben\u00f6tigt, um die Anwendung zu starten:</p> <pre><code>pip install uvicorn\nuvicorn main:app --reload\n</code></pre>"},{"location":"fastapi/intro/#fastapi-vs-flask","title":"FastAPI vs. Flask","text":"<p>FastAPI und Flask sind beide beliebte Python-Frameworks zur API-Entwicklung, unterscheiden sich jedoch erheblich in ihrer Funktionsweise und ihrem Anwendungsbereich.</p>"},{"location":"fastapi/intro/#hauptunterschiede","title":"Hauptunterschiede","text":"Merkmal Flask FastAPI Asynchronit\u00e4t Unterst\u00fctzung nur mit zus\u00e4tzlichen Bibliotheken wie <code>flask-async</code> Eingebaute Unterst\u00fctzung f\u00fcr <code>async</code> und <code>await</code> Performance Moderate Geschwindigkeit Hohe Performance durch asynchrone Architektur Datenvalidierung Keine eingebaute Validierung, zus\u00e4tzliche Bibliotheken wie <code>marshmallow</code> erforderlich Integrierte Validierung mit Pydantic Dokumentation Keine automatische Dokumentation Automatische Generierung von Swagger UI und Redoc Ideal f\u00fcr Einfache APIs und Anwendungen APIs mit hoher Leistung und komplexen Datenvalidierungsanforderungen"},{"location":"fastapi/intro/#wann-man-fastapi-verwenden-sollte","title":"Wann man FastAPI verwenden sollte","text":"<ul> <li>Wenn hohe Performance und Skalierbarkeit gefordert sind.</li> <li>F\u00fcr APIs, die asynchrone Verarbeitung ben\u00f6tigen.</li> <li>Bei Projekten, in denen die automatische Dokumentation n\u00fctzlich ist.</li> </ul>"},{"location":"fastapi/intro/#wann-flask-geeigneter-ist","title":"Wann Flask geeigneter ist","text":"<ul> <li>Bei einfachen Anwendungen oder Prototypen, die nur grundlegende Funktionalit\u00e4ten ben\u00f6tigen.</li> <li>Wenn Asynchronit\u00e4t und Performance keine kritischen Anforderungen sind.</li> </ul>"},{"location":"fastapi/sqlmodel/","title":"Arbeiten mit SQLModel in FastAPI","text":"<p>SQLModel ist eine Bibliothek, die SQLAlchemy und Pydantic kombiniert. Sie erm\u00f6glicht es dir, Datenbankmodelle in FastAPI zu integrieren, ohne auf umfangreiche ORM-Definitionen verzichten zu m\u00fcssen. SQLModel baut auf SQLAlchemy auf und verwendet Pydantic zur Validierung der Daten, sodass du Datenbankmodelle erstellen und gleichzeitig die Vorteile der Datenvalidierung von Pydantic nutzen kannst.</p>"},{"location":"fastapi/sqlmodel/#was-ist-sqlmodel","title":"Was ist SQLModel?","text":"<p>SQLModel ist eine Bibliothek, die es erm\u00f6glicht, SQL-Datenbanken in FastAPI-Anwendungen zu integrieren. Sie stellt eine einfache Schnittstelle zur Verf\u00fcgung, die es dir erm\u00f6glicht, sowohl Datenbankmodelle zu definieren als auch mit der Datenbank zu interagieren \u2013 alles in einer sauberen und einheitlichen API.</p> <p>SQLModel erm\u00f6glicht die Definition von Pydantic-Modellen, die gleichzeitig auch Datenbankmodelle sind. Das bedeutet, dass du nur ein Modell schreiben musst, um sowohl mit der Datenbank als auch mit FastAPI zu arbeiten.</p>"},{"location":"fastapi/sqlmodel/#installation","title":"Installation","text":"<pre><code>pip install sqlmodel\n</code></pre>"},{"location":"fastapi/sqlmodel/#erstellen-eines-einfachen-sqlmodel-datenmodells","title":"Erstellen eines einfachen SQLModel-Datenmodells","text":"<p>Ein SQLModel-Datenmodell ist sehr \u00e4hnlich wie ein Pydantic-Modell, aber mit zus\u00e4tzlichen SQLAlchemy-Features wie <code>Field</code> und <code>Relationship</code> f\u00fcr die Datenbankinteraktion. </p> <pre><code>from sqlmodel import Field, SQLModel\n\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n    email: str\n    age: int\n</code></pre> <p>In diesem Beispiel haben wir ein einfaches User-Modell erstellt, das die Felder <code>id</code>, <code>name</code>, <code>email</code> und <code>age</code> enth\u00e4lt. Das <code>table=True</code>-Attribut signalisiert, dass dieses Modell eine Tabelle in der Datenbank repr\u00e4sentiert.</p>"},{"location":"fastapi/sqlmodel/#aufgabe","title":"Aufgabe","text":"<p>Erstelle ein weiteres Datenmodell, das <code>Product</code>-Daten mit den Feldern <code>name</code>, <code>price</code> und <code>description</code> speichert. Vergiss nicht, die <code>id</code> als Prim\u00e4rschl\u00fcssel hinzuzuf\u00fcgen.</p>"},{"location":"fastapi/sqlmodel/#datenbankverbindungen-und-sessions","title":"Datenbankverbindungen und Sessions","text":"<p>Eine der wichtigsten Aufgaben beim Arbeiten mit SQLModel ist die Verbindung zur Datenbank und die Verwaltung von Sessions, um Transaktionen durchzuf\u00fchren. SQLModel baut auf SQLAlchemy auf, sodass wir die gleiche Methode verwenden, um die Verbindung zur Datenbank herzustellen.</p>"},{"location":"fastapi/sqlmodel/#verbindung-zur-datenbank-herstellen","title":"Verbindung zur Datenbank herstellen","text":"<p>Du kannst SQLModel mit einer SQLite-Datenbank oder einer anderen unterst\u00fctzten Datenbank wie PostgreSQL oder MySQL verwenden. Hier ist ein einfaches Beispiel f\u00fcr die Verbindung zu einer SQLite-Datenbank:</p> <pre><code>from sqlmodel import create_engine, Session\n\n# Erstelle die Verbindung zur SQLite-Datenbank\nengine = create_engine(\"sqlite:///database.db\")\n\n# Erstelle die Tabellen in der Datenbank (falls sie noch nicht existieren)\nSQLModel.metadata.create_all(engine)\n</code></pre>"},{"location":"fastapi/sqlmodel/#arbeiten-mit-sessions","title":"Arbeiten mit Sessions","text":"<p>Um mit der Datenbank zu interagieren, musst du eine Session erstellen, die es dir erm\u00f6glicht, Datens\u00e4tze zu lesen, zu schreiben und zu aktualisieren.</p> <pre><code>from sqlmodel import Session\n\n# \u00d6ffne eine Session, um mit der Datenbank zu interagieren\nwith Session(engine) as session:\n    # Beispiel: Hinzuf\u00fcgen eines neuen Benutzers\n    user = User(name=\"John Doe\", email=\"johndoe@example.com\", age=30)\n    session.add(user)\n    session.commit()\n</code></pre>"},{"location":"fastapi/sqlmodel/#aufgabe_1","title":"Aufgabe","text":"<p>Erstelle eine neue <code>Product</code>-Instanz, f\u00fcge sie zur Datenbank hinzu und best\u00e4tige die Transaktion mit <code>session.commit()</code>.</p>"},{"location":"fastapi/sqlmodel/#crud-operationen-mit-sqlmodel","title":"CRUD-Operationen mit SQLModel","text":"<p>SQLModel macht es einfach, grundlegende CRUD-Operationen (Create, Read, Update, Delete) auf Datenbanken durchzuf\u00fchren. Nachdem du die Datenbankverbindung und das Modell eingerichtet hast, kannst du Datens\u00e4tze einfach erstellen und abfragen.</p>"},{"location":"fastapi/sqlmodel/#erstellen-eines-datensatzes-create","title":"Erstellen eines Datensatzes (Create)","text":"<pre><code>with Session(engine) as session:\n    new_user = User(name=\"Jane Doe\", email=\"janedoe@example.com\", age=25)\n    session.add(new_user)\n    session.commit()\n</code></pre>"},{"location":"fastapi/sqlmodel/#lesen-von-datensatzen-read","title":"Lesen von Datens\u00e4tzen (Read)","text":"<pre><code>with Session(engine) as session:\n    user = session.query(User).filter(User.name == \"Jane Doe\").first()\n    print(user)\n</code></pre>"},{"location":"fastapi/sqlmodel/#aktualisieren-von-datensatzen-update","title":"Aktualisieren von Datens\u00e4tzen (Update)","text":"<pre><code>with Session(engine) as session:\n    user = session.query(User).filter(User.name == \"Jane Doe\").first()\n    if user:\n        user.age = 26\n        session.commit()\n</code></pre>"},{"location":"fastapi/sqlmodel/#loschen-von-datensatzen-delete","title":"L\u00f6schen von Datens\u00e4tzen (Delete)","text":"<pre><code>with Session(engine) as session:\n    user = session.query(User).filter(User.name == \"Jane Doe\").first()\n    if user:\n        session.delete(user)\n        session.commit()\n</code></pre>"},{"location":"fastapi/sqlmodel/#aufgabe_2","title":"Aufgabe","text":"<p>Erweitere das <code>User</code>-Modell um ein <code>address</code>-Feld und f\u00fchre eine <code>UPDATE</code>-Operation durch, um die Adresse eines bestimmten Benutzers zu \u00e4ndern.</p>"},{"location":"fastapi/sqlmodel/#integration-von-sqlmodel-mit-fastapi","title":"Integration von SQLModel mit FastAPI","text":"<p>Ein gro\u00dfer Vorteil von SQLModel ist, dass es nahtlos mit FastAPI integriert werden kann. Du kannst SQLModel-Modelle direkt in deine FastAPI-Routen einbinden, um API-Endpunkte zu erstellen, die mit der Datenbank interagieren.</p>"},{"location":"fastapi/sqlmodel/#beispiel-fur-einen-fastapi-endpunkt-mit-sqlmodel","title":"Beispiel f\u00fcr einen FastAPI-Endpunkt mit SQLModel","text":"<pre><code>from fastapi import FastAPI\nfrom sqlmodel import Session, select\n\napp = FastAPI()\n\n@app.post(\"/users/\")\nasync def create_user(user: User):\n    with Session(engine) as session:\n        session.add(user)\n        session.commit()\n    return {\"user\": user}\n</code></pre> <p>In diesem Beispiel haben wir eine <code>POST</code>-Route erstellt, die ein <code>User</code>-Objekt entgegennimmt und es in die Datenbank speichert.</p>"},{"location":"fastapi/sqlmodel/#aufgabe_3","title":"Aufgabe","text":"<p>Erstelle eine <code>GET</code>-Route, die alle Benutzer aus der Datenbank abruft und zur\u00fcckgibt.</p>"},{"location":"fastapi/task/","title":"Vorhersage des Einkommens basierend auf dem Adult Income Dataset","text":"<p>In dieser Aufgabe wirst du das Adult Income Dataset verwenden, um ein einfaches API-Modell zu erstellen, das die Wahrscheinlichkeit vorhersagt, ob jemand mehr als 50.000 USD j\u00e4hrlich verdient, basierend auf verschiedenen demografischen Merkmalen. Du wirst SQLModel f\u00fcr das Speichern der Daten in einer Datenbank und FastAPI f\u00fcr die API-Erstellung verwenden.</p>"},{"location":"fastapi/task/#aufgabe-1-datenvorbereitung-und-verstandnis","title":"Aufgabe 1: Datenvorbereitung und -verst\u00e4ndnis","text":"<p>Lade das Adult Income Dataset herunter und analysiere die Spalten. Erstelle ein Streamlit Dashboard oder Jupyter Notebook, um den Datensatz visuell aufzubereiten. Der Datensatz enth\u00e4lt folgende Merkmale:</p> <ul> <li><code>age</code>: Alter der Person</li> <li><code>workclass</code>: Arbeitsverh\u00e4ltnis (z.B. privat, \u00f6ffentlich)</li> <li><code>fnlwgt</code>: Gewicht (repr\u00e4sentiert die Anzahl der Menschen, die in der Stichprobe repr\u00e4sentiert sind)</li> <li><code>education</code>: H\u00f6chster Bildungsabschluss</li> <li><code>education-num</code>: Bildung in numerischer Form</li> <li><code>marital-status</code>: Familienstand</li> <li><code>occupation</code>: Beruf</li> <li><code>relationship</code>: Beziehung zum Haushaltsvorstand</li> <li><code>race</code>: Rasse</li> <li><code>sex</code>: Geschlecht</li> <li><code>capital-gain</code>: Kapitalgewinne</li> <li><code>capital-loss</code>: Kapitalverlust</li> <li><code>hours-per-week</code>: Arbeitsstunden pro Woche</li> <li><code>native-country</code>: Geburtsland</li> <li><code>income</code>: Einkommen (mehr als 50K oder weniger)</li> </ul>"},{"location":"fastapi/task/#aufgabe-2-erstellen-eines-sqlmodel-datenmodells","title":"Aufgabe 2: Erstellen eines SQLModel-Datenmodells","text":"<p>Erstelle ein <code>User</code>-Datenmodell mit SQLModel, das die oben genannten Merkmale repr\u00e4sentiert. Definiere auch den Typ der Merkmale (z. B. <code>age</code> als Integer, <code>education</code> als String). </p>"},{"location":"fastapi/task/#aufgabe-3-api-erstellung-mit-fastapi","title":"Aufgabe 3: API-Erstellung mit FastAPI","text":"<p>Erstelle eine FastAPI-Anwendung, die folgende Funktionalit\u00e4ten bietet:</p> <ol> <li> <p>Daten hinzuf\u00fcgen: Erstelle eine POST-Route, die es erm\u00f6glicht, neue Benutzerdaten hinzuzuf\u00fcgen. Die Route sollte alle Merkmale des Datensatzes akzeptieren.</p> </li> <li> <p>Daten abfragen: Erstelle eine GET-Route, um alle gespeicherten Benutzerdaten abzurufen.</p> </li> <li> <p>Einkommensvorhersage: Erstelle eine weitere POST-Route, die basierend auf den eingegebenen demografischen Merkmalen vorhersagt, ob das Einkommen mehr als 50.000 USD betr\u00e4gt oder nicht. Diese Route sollte ein Modell wie z. B. einen einfachen Entscheidungsbaum verwenden (der zuvor auf den Daten trainiert wurde), um die Vorhersage zu treffen.</p> </li> </ol>"},{"location":"fastapi/task/#aufgabe-4-testen-der-api-mit-postman-oder-einem-anderen-api-client","title":"Aufgabe 4: Testen der API mit Postman oder einem anderen API-Client","text":"<ol> <li> <p>Daten hinzuf\u00fcgen: Verwende die POST-Route <code>/add-user</code> (oder eine benannte Route) zum Hinzuf\u00fcgen eines neuen Datensatzes.</p> </li> <li> <p>Daten abfragen: Verwende die GET-Route <code>/users</code>, um alle gespeicherten Benutzer abzurufen.</p> </li> <li> <p>Einkommensvorhersage: Teste die <code>/predict-income/</code>-Route, indem du verschiedene Werte f\u00fcr <code>age</code>, <code>hours-per-week</code> und andere Merkmale eingibst.</p> </li> </ol>"},{"location":"fastapi/task/#aufgabe-5-zusatz-analyse-und-modellverbesserung","title":"Aufgabe 5 (Zusatz): Analyse und Modellverbesserung","text":"<p>Nachdem du die API erstellt hast, analysiere die Vorhersageergebnisse und \u00fcberlege, wie du das Modell verbessern kannst</p>"}]}